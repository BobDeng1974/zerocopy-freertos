!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A_BLOCK_LINK	.\freertos\portable\memang\heap_4.c	/^typedef struct A_BLOCK_LINK$/;"	s	file:
BARCNT_H_	.\barcnt.h	23;"	d
BARRIER_H_	.\Barrier.h	24;"	d
Barrier	.\Barrier.h	/^typedef struct Barrier$/;"	s
Barrier	.\Barrier.h	/^} Barrier;$/;"	t	typeref:struct:Barrier
BaseType_t	.\freertos\portable\mingw\portmacro.h	/^typedef long BaseType_t;$/;"	t
BlockLink_t	.\freertos\portable\memang\heap_4.c	/^} BlockLink_t;$/;"	t	typeref:struct:A_BLOCK_LINK	file:
CBUFF_ARRAY_LENGTH	.\main_app.c	43;"	d	file:
CIRCULARBUFFER_H_	.\CircularBuffer.h	31;"	d
CONSUMERTASKPARAMS_H_	.\consumer_task.h	24;"	d
CO_ROUTINE_H	.\freertos\include\croutine.h	67;"	d
CRCB_t	.\freertos\include\croutine.h	/^} CRCB_t; \/* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. *\/$/;"	t	typeref:struct:corCoRoutineControlBlock
CallbackParameters_t	.\freertos\timers.c	/^} CallbackParameters_t;$/;"	t	typeref:struct:tmrCallbackParameters	file:
CircularBuffer	.\CircularBuffer.h	/^typedef struct CircularBuffer$/;"	s
CircularBuffer	.\CircularBuffer.h	/^} CircularBuffer;$/;"	t	typeref:struct:CircularBuffer
CircularBufferInitialize	.\CircularBuffer.c	/^CircularBufferInitialize(CircularBuffer *c, unsigned char *buffer, unsigned int buffer_size)$/;"	f
CircularBufferInitializeLockable	.\CircularBuffer.c	/^CircularBufferInitializeLockable(CircularBufferLockable *c, unsigned char *buffer, unsigned int buffer_size)$/;"	f
CircularBufferLockable	.\CircularBuffer.h	/^typedef struct CircularBufferLockable$/;"	s
CircularBufferLockable	.\CircularBuffer.h	/^} CircularBufferLockable;$/;"	t	typeref:struct:CircularBufferLockable
CircularBufferRead	.\CircularBuffer.c	/^int CircularBufferRead(CircularBuffer *c, unsigned char *dataOut, unsigned int length)$/;"	f
CircularBufferReadLockable	.\CircularBuffer.c	/^CircularBufferReadLockable(CircularBufferLockable *c, unsigned char *dataOut, unsigned int length){$/;"	f
CircularBufferWrite	.\CircularBuffer.c	/^int CircularBufferWrite(CircularBuffer *c, unsigned char *dataIn, unsigned int length)$/;"	f
CircularBufferWriteLockable	.\CircularBuffer.c	/^CircularBufferWriteLockable(CircularBufferLockable *c, unsigned char *dataIn, unsigned int length)$/;"	f
CoRoutineHandle_t	.\freertos\include\croutine.h	/^typedef void * CoRoutineHandle_t;$/;"	t
DaemonTaskMessage_t	.\freertos\timers.c	/^} DaemonTaskMessage_t;$/;"	t	typeref:struct:tmrTimerQueueMessage	file:
EVENT_GROUPS_H	.\freertos\include\event_groups.h	67;"	d
EventBits_t	.\freertos\include\event_groups.h	/^typedef TickType_t EventBits_t;$/;"	t
EventGroupHandle_t	.\freertos\include\event_groups.h	/^typedef void * EventGroupHandle_t;$/;"	t
EventGroup_t	.\freertos\event_groups.c	/^} EventGroup_t;$/;"	t	typeref:struct:xEventGroupDefinition	file:
FREERTOS_CONFIG_H	.\freertos\FreeRTOSConfig.h	68;"	d
INCLUDE_eTaskGetState	.\freertos\FreeRTOSConfig.h	141;"	d
INCLUDE_eTaskGetState	.\freertos\include\FreeRTOS.h	205;"	d
INCLUDE_pcTaskGetTaskName	.\freertos\FreeRTOSConfig.h	140;"	d
INCLUDE_pcTaskGetTaskName	.\freertos\include\FreeRTOS.h	193;"	d
INCLUDE_uxTaskGetStackHighWaterMark	.\freertos\FreeRTOSConfig.h	136;"	d
INCLUDE_uxTaskGetStackHighWaterMark	.\freertos\include\FreeRTOS.h	201;"	d
INCLUDE_uxTaskPriorityGet	.\freertos\FreeRTOSConfig.h	130;"	d
INCLUDE_vTaskCleanUpResources	.\freertos\FreeRTOSConfig.h	132;"	d
INCLUDE_vTaskDelay	.\freertos\FreeRTOSConfig.h	135;"	d
INCLUDE_vTaskDelayUntil	.\freertos\FreeRTOSConfig.h	134;"	d
INCLUDE_vTaskDelete	.\freertos\FreeRTOSConfig.h	131;"	d
INCLUDE_vTaskPrioritySet	.\freertos\FreeRTOSConfig.h	129;"	d
INCLUDE_vTaskSuspend	.\freertos\FreeRTOSConfig.h	133;"	d
INCLUDE_xEventGroupSetBitFromISR	.\freertos\include\FreeRTOS.h	249;"	d
INCLUDE_xQueueGetMutexHolder	.\freertos\include\FreeRTOS.h	185;"	d
INCLUDE_xSemaphoreGetMutexHolder	.\freertos\FreeRTOSConfig.h	142;"	d
INCLUDE_xSemaphoreGetMutexHolder	.\freertos\include\FreeRTOS.h	189;"	d
INCLUDE_xTaskGetCurrentTaskHandle	.\freertos\include\FreeRTOS.h	285;"	d
INCLUDE_xTaskGetIdleTaskHandle	.\freertos\FreeRTOSConfig.h	139;"	d
INCLUDE_xTaskGetIdleTaskHandle	.\freertos\include\FreeRTOS.h	177;"	d
INCLUDE_xTaskGetSchedulerState	.\freertos\FreeRTOSConfig.h	137;"	d
INCLUDE_xTaskGetSchedulerState	.\freertos\include\FreeRTOS.h	281;"	d
INCLUDE_xTaskResumeFromISR	.\freertos\include\FreeRTOS.h	245;"	d
INCLUDE_xTimerGetTimerDaemonTaskHandle	.\freertos\FreeRTOSConfig.h	138;"	d
INCLUDE_xTimerGetTimerDaemonTaskHandle	.\freertos\include\FreeRTOS.h	181;"	d
INCLUDE_xTimerPendFunctionCall	.\freertos\FreeRTOSConfig.h	143;"	d
INCLUDE_xTimerPendFunctionCall	.\freertos\include\FreeRTOS.h	253;"	d
INC_FREERTOS_H	.\freertos\include\FreeRTOS.h	67;"	d
INC_TASK_H	.\freertos\include\task.h	68;"	d
LIST_H	.\freertos\include\list.h	96;"	d
ListItem_t	.\freertos\include\list.h	/^typedef struct xLIST_ITEM ListItem_t;					\/* For some reason lint wants this as two separate definitions. *\/$/;"	t	typeref:struct:xLIST_ITEM
List_t	.\freertos\include\list.h	/^} List_t;$/;"	t	typeref:struct:xLIST
MPU_WRAPPERS_H	.\freertos\include\mpu_wrappers.h	67;"	d
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\event_groups.c	72;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\event_groups.c	84;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\portable\memang\heap_4.c	79;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\portable\memang\heap_4.c	84;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\queue.c	72;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\queue.c	86;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\tasks.c	73;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\tasks.c	85;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\timers.c	72;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	.\freertos\timers.c	87;"	d	file:
MemoryRegion_t	.\freertos\include\task.h	/^} MemoryRegion_t;$/;"	t	typeref:struct:xMEMORY_REGION
MiniListItem_t	.\freertos\include\list.h	/^typedef struct xMINI_LIST_ITEM MiniListItem_t;$/;"	t	typeref:struct:xMINI_LIST_ITEM
NUM_OF_CONSUMERS	.\main_app.c	45;"	d	file:
PORTABLE_H	.\freertos\include\portable.h	71;"	d
PORTMACRO_H	.\freertos\portable\mingw\portmacro.h	67;"	d
PRIVILEGED_DATA	.\freertos\include\mpu_wrappers.h	138;"	d
PRIVILEGED_DATA	.\freertos\include\mpu_wrappers.h	145;"	d
PRIVILEGED_FUNCTION	.\freertos\include\mpu_wrappers.h	132;"	d
PRIVILEGED_FUNCTION	.\freertos\include\mpu_wrappers.h	137;"	d
PRIVILEGED_FUNCTION	.\freertos\include\mpu_wrappers.h	144;"	d
PRODUCERTASKPARAMS_H_	.\producer_task.h	24;"	d
PROJDEFS_H	.\freertos\include\projdefs.h	67;"	d
PendedFunction_t	.\freertos\include\timers.h	/^typedef void (*PendedFunction_t)( void *, uint32_t );$/;"	t
QUEUEMESSAGE_H_	.\queuemsg.h	31;"	d
QUEUE_H	.\freertos\include\queue.h	68;"	d
QUEUE_REGISTRY_ITEM	.\freertos\queue.c	/^	typedef struct QUEUE_REGISTRY_ITEM$/;"	s	file:
QueueDefinition	.\freertos\queue.c	/^typedef struct QueueDefinition$/;"	s	file:
QueueHandle_t	.\freertos\include\queue.h	/^typedef void * QueueHandle_t;$/;"	t
QueueRegistryItem_t	.\freertos\queue.c	/^	typedef xQueueRegistryItem QueueRegistryItem_t;$/;"	t	file:
QueueSetHandle_t	.\freertos\include\queue.h	/^typedef void * QueueSetHandle_t;$/;"	t
QueueSetMemberHandle_t	.\freertos\include\queue.h	/^typedef void * QueueSetMemberHandle_t;$/;"	t
Queue_t	.\freertos\queue.c	/^typedef xQUEUE Queue_t;$/;"	t	file:
RINGBUF_H_	.\ringbuf.h	30;"	d
SEMAPHORE_H	.\freertos\include\semphr.h	67;"	d
STACK_MACROS_H	.\freertos\include\StackMacros.h	67;"	d
SemaphoreHandle_t	.\freertos\include\semphr.h	/^typedef QueueHandle_t SemaphoreHandle_t;$/;"	t
StackType_t	.\freertos\portable\mingw\portmacro.h	/^typedef portSTACK_TYPE StackType_t;$/;"	t
TCB_t	.\freertos\tasks.c	/^typedef tskTCB TCB_t;$/;"	t	file:
TIMERS_H	.\freertos\include\timers.h	68;"	d
TaskFunction_t	.\freertos\include\projdefs.h	/^typedef void (*TaskFunction_t)( void * );$/;"	t
TaskHandle_t	.\freertos\include\task.h	/^typedef void * TaskHandle_t;$/;"	t
TaskHookFunction_t	.\freertos\include\task.h	/^typedef BaseType_t (*TaskHookFunction_t)( void * );$/;"	t
TaskParameters_t	.\freertos\include\task.h	/^} TaskParameters_t;$/;"	t	typeref:struct:xTASK_PARAMETERS
TaskStatus_t	.\freertos\include\task.h	/^} TaskStatus_t;$/;"	t	typeref:struct:xTASK_STATUS
TickType_t	.\freertos\portable\mingw\portmacro.h	/^    typedef uint16_t TickType_t;$/;"	t
TickType_t	.\freertos\portable\mingw\portmacro.h	/^    typedef uint32_t TickType_t;$/;"	t
TimeOut_t	.\freertos\include\task.h	/^} TimeOut_t;$/;"	t	typeref:struct:xTIME_OUT
TimerCallbackFunction_t	.\freertos\include\timers.h	/^typedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );$/;"	t
TimerHandle_t	.\freertos\include\timers.h	/^typedef void * TimerHandle_t;$/;"	t
TimerParameter_t	.\freertos\timers.c	/^} TimerParameter_t;$/;"	t	typeref:struct:tmrTimerParameters	file:
Timer_t	.\freertos\timers.c	/^typedef xTIMER Timer_t;$/;"	t	file:
UBaseType_t	.\freertos\portable\mingw\portmacro.h	/^typedef unsigned long UBaseType_t;$/;"	t
X86_ATOMIC	.\Barrier.c	27;"	d	file:
X86_ATOMIC	.\barcnt.c	26;"	d	file:
_atomic_ringbuf_t	.\ringbuf.h	/^typedef struct _atomic_ringbuf_t$/;"	s
_barcnt_t	.\barcnt.h	/^typedef struct _barcnt_t$/;"	s
_queuemsg_t	.\queuemsg.h	/^typedef struct _queuemsg_t$/;"	s
_ringbuf_t	.\ringbuf.h	/^typedef struct _ringbuf_t$/;"	s
atomic_ringbuf_t	.\ringbuf.h	/^} atomic_ringbuf_t;$/;"	t	typeref:struct:_atomic_ringbuf_t
barcnt_t	.\barcnt.h	/^} barcnt_t;$/;"	t	typeref:struct:_barcnt_t
barrier_array	.\producer_task.h	/^	barcnt_t* barrier_array;$/;"	m	struct:xProducerTaskParams
barrier_count	.\Barrier.h	/^	unsigned int barrier_count;$/;"	m	struct:Barrier
barrier_count	.\barcnt.h	/^	unsigned int barrier_count;$/;"	m	struct:_barcnt_t
buffer	.\CircularBuffer.h	/^	char* buffer; \/\/ TODO: this should be portBASE_TYPE$/;"	m	struct:CircularBuffer
buffer	.\CircularBuffer.h	/^	char* buffer; \/\/ TODO: this should be portBASE_TYPE$/;"	m	struct:CircularBufferLockable
buffer	.\ringbuf.h	/^	char* buffer; \/\/ TODO: this should be portBASE_TYPE$/;"	m	struct:_atomic_ringbuf_t
buffer	.\ringbuf.h	/^	char* buffer; \/\/ TODO: this should be portBASE_TYPE$/;"	m	struct:_ringbuf_t
buffer_len	.\queuemsg.h	/^	size_t buffer_len;$/;"	m	struct:_queuemsg_t
buffer_ptr	.\queuemsg.h	/^	void *buffer_ptr;$/;"	m	struct:_queuemsg_t
circular_buffer	.\consumer_task.h	/^	atomic_ringbuf_t* circular_buffer;$/;"	m	struct:xConsumerTaskInitParams
circular_buffer	.\consumer_task.h	/^	atomic_ringbuf_t* circular_buffer;$/;"	m	struct:xConsumerTaskParams
circular_buffer	.\producer_task.h	/^	atomic_ringbuf_t* circular_buffer;$/;"	m	struct:xProducerTaskInitParams
circular_buffer	.\producer_task.h	/^	atomic_ringbuf_t* circular_buffer;$/;"	m	struct:xProducerTaskParams
configASSERT	.\freertos\FreeRTOSConfig.h	148;"	d
configASSERT	.\freertos\include\FreeRTOS.h	257;"	d
configASSERT_DEFINED	.\freertos\include\FreeRTOS.h	258;"	d
configASSERT_DEFINED	.\freertos\include\FreeRTOS.h	260;"	d
configCHECK_FOR_STACK_OVERFLOW	.\freertos\FreeRTOSConfig.h	92;"	d
configCHECK_FOR_STACK_OVERFLOW	.\freertos\include\FreeRTOS.h	397;"	d
configCONSUMER_STACK_SIZE	.\consumer_task.c	42;"	d	file:
configENABLE_BACKWARD_COMPATIBILITY	.\freertos\include\FreeRTOS.h	723;"	d
configEXPECTED_IDLE_TIME_BEFORE_SLEEP	.\freertos\include\FreeRTOS.h	665;"	d
configGENERATE_RUN_TIME_STATS	.\freertos\FreeRTOSConfig.h	112;"	d
configGENERATE_RUN_TIME_STATS	.\freertos\include\FreeRTOS.h	619;"	d
configIDLE_SHOULD_YIELD	.\freertos\FreeRTOSConfig.h	90;"	d
configIDLE_SHOULD_YIELD	.\freertos\include\FreeRTOS.h	237;"	d
configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS	.\freertos\include\FreeRTOS.h	697;"	d
configLIST_VOLATILE	.\freertos\include\list.h	127;"	d
configMAX_CO_ROUTINE_PRIORITIES	.\freertos\FreeRTOSConfig.h	118;"	d
configMAX_PRIORITIES	.\freertos\FreeRTOSConfig.h	107;"	d
configMAX_TASK_NAME_LEN	.\freertos\FreeRTOSConfig.h	87;"	d
configMAX_TASK_NAME_LEN	.\freertos\include\FreeRTOS.h	233;"	d
configMINIMAL_STACK_SIZE	.\freertos\FreeRTOSConfig.h	85;"	d
configPOST_SLEEP_PROCESSING	.\freertos\include\FreeRTOS.h	681;"	d
configPRE_SLEEP_PROCESSING	.\freertos\include\FreeRTOS.h	677;"	d
configPRODUCER_STACK_SIZE	.\producer_task.c	41;"	d	file:
configQUEUE_REGISTRY_SIZE	.\freertos\FreeRTOSConfig.h	94;"	d
configQUEUE_REGISTRY_SIZE	.\freertos\include\FreeRTOS.h	310;"	d
configTICK_RATE_HZ	.\freertos\FreeRTOSConfig.h	84;"	d
configTIMER_QUEUE_LENGTH	.\freertos\FreeRTOSConfig.h	104;"	d
configTIMER_TASK_PRIORITY	.\freertos\FreeRTOSConfig.h	103;"	d
configTIMER_TASK_STACK_DEPTH	.\freertos\FreeRTOSConfig.h	105;"	d
configTOTAL_HEAP_SIZE	.\freertos\FreeRTOSConfig.h	86;"	d
configUSE_16_BIT_TICKS	.\freertos\FreeRTOSConfig.h	89;"	d
configUSE_ALTERNATIVE_API	.\freertos\FreeRTOSConfig.h	98;"	d
configUSE_ALTERNATIVE_API	.\freertos\include\FreeRTOS.h	225;"	d
configUSE_APPLICATION_TASK_TAG	.\freertos\FreeRTOSConfig.h	96;"	d
configUSE_APPLICATION_TASK_TAG	.\freertos\include\FreeRTOS.h	197;"	d
configUSE_COUNTING_SEMAPHORES	.\freertos\FreeRTOSConfig.h	97;"	d
configUSE_COUNTING_SEMAPHORES	.\freertos\include\FreeRTOS.h	221;"	d
configUSE_CO_ROUTINES	.\freertos\FreeRTOSConfig.h	117;"	d
configUSE_IDLE_HOOK	.\freertos\FreeRTOSConfig.h	82;"	d
configUSE_MALLOC_FAILED_HOOK	.\freertos\FreeRTOSConfig.h	95;"	d
configUSE_MALLOC_FAILED_HOOK	.\freertos\include\FreeRTOS.h	641;"	d
configUSE_MUTEXES	.\freertos\FreeRTOSConfig.h	91;"	d
configUSE_MUTEXES	.\freertos\include\FreeRTOS.h	213;"	d
configUSE_NEWLIB_REENTRANT	.\freertos\include\FreeRTOS.h	701;"	d
configUSE_PORT_OPTIMISED_TASK_SELECTION	.\freertos\FreeRTOSConfig.h	81;"	d
configUSE_PORT_OPTIMISED_TASK_SELECTION	.\freertos\include\FreeRTOS.h	102;"	d
configUSE_PREEMPTION	.\freertos\FreeRTOSConfig.h	80;"	d
configUSE_QUEUE_SETS	.\freertos\FreeRTOSConfig.h	99;"	d
configUSE_QUEUE_SETS	.\freertos\include\FreeRTOS.h	685;"	d
configUSE_RECURSIVE_MUTEXES	.\freertos\FreeRTOSConfig.h	93;"	d
configUSE_RECURSIVE_MUTEXES	.\freertos\include\FreeRTOS.h	209;"	d
configUSE_STATS_FORMATTING_FUNCTIONS	.\freertos\FreeRTOSConfig.h	124;"	d
configUSE_STATS_FORMATTING_FUNCTIONS	.\freertos\include\FreeRTOS.h	705;"	d
configUSE_TICKLESS_IDLE	.\freertos\include\FreeRTOS.h	673;"	d
configUSE_TICK_HOOK	.\freertos\FreeRTOSConfig.h	83;"	d
configUSE_TIMERS	.\freertos\FreeRTOSConfig.h	102;"	d
configUSE_TIMERS	.\freertos\include\FreeRTOS.h	217;"	d
configUSE_TIME_SLICING	.\freertos\include\FreeRTOS.h	693;"	d
configUSE_TRACE_FACILITY	.\freertos\FreeRTOSConfig.h	88;"	d
configUSE_TRACE_FACILITY	.\freertos\include\FreeRTOS.h	713;"	d
consumer_count_barrier	.\queuemsg.h	/^	barcnt_t *consumer_count_barrier;$/;"	m	struct:_queuemsg_t
consumer_id	.\consumer_task.h	/^	unsigned int consumer_id;$/;"	m	struct:xConsumerTaskInitParams
consumer_id	.\consumer_task.h	/^	unsigned int consumer_id;$/;"	m	struct:xConsumerTaskParams
consumer_task_count	.\producer_task.h	/^	unsigned int consumer_task_count;$/;"	m	struct:xProducerTaskInitParams
consumer_task_count	.\producer_task.h	/^	unsigned int consumer_task_count;$/;"	m	struct:xProducerTaskParams
corCoRoutineControlBlock	.\freertos\include\croutine.h	/^typedef struct corCoRoutineControlBlock$/;"	s
corINITIAL_STATE	.\freertos\croutine.c	93;"	d	file:
crCOROUTINE_CODE	.\freertos\include\croutine.h	/^typedef void (*crCOROUTINE_CODE)( CoRoutineHandle_t, UBaseType_t );$/;"	t
crDELAY	.\freertos\include\croutine.h	328;"	d
crEND	.\freertos\include\croutine.h	273;"	d
crQUEUE_RECEIVE	.\freertos\include\croutine.h	510;"	d
crQUEUE_RECEIVE_FROM_ISR	.\freertos\include\croutine.h	732;"	d
crQUEUE_SEND	.\freertos\include\croutine.h	418;"	d
crQUEUE_SEND_FROM_ISR	.\freertos\include\croutine.h	619;"	d
crSET_STATE0	.\freertos\include\croutine.h	279;"	d
crSET_STATE1	.\freertos\include\croutine.h	280;"	d
crSTART	.\freertos\include\croutine.h	242;"	d
dec_barcnt	.\barcnt.c	/^int dec_barcnt(barcnt_t *b)$/;"	f
decrement_barrier	.\Barrier.c	/^int decrement_barrier(Barrier *b)$/;"	f
eAbortSleep	.\freertos\include\task.h	/^	eAbortSleep = 0,		\/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. *\/$/;"	e	enum:__anon2
eBlocked	.\freertos\include\task.h	/^	eBlocked,		\/* The task being queried is in the Blocked state. *\/$/;"	e	enum:__anon1
eCurrentState	.\freertos\include\task.h	/^	eTaskState eCurrentState;		\/* The state in which the task existed when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS
eDeleted	.\freertos\include\task.h	/^	eDeleted		\/* The task being queried has been deleted, but its TCB has not yet been freed. *\/$/;"	e	enum:__anon1
eNoTasksWaitingTimeout	.\freertos\include\task.h	/^	eNoTasksWaitingTimeout	\/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. *\/$/;"	e	enum:__anon2
eReady	.\freertos\include\task.h	/^	eReady,			\/* The task being queried is in a read or pending ready list. *\/$/;"	e	enum:__anon1
eRunning	.\freertos\include\task.h	/^	eRunning = 0,	\/* A task is querying the state of itself, so must be running. *\/$/;"	e	enum:__anon1
eSleepModeStatus	.\freertos\include\task.h	/^} eSleepModeStatus;$/;"	t	typeref:enum:__anon2
eStandardSleep	.\freertos\include\task.h	/^	eStandardSleep,			\/* Enter a sleep mode that will not last any longer than the expected idle time. *\/$/;"	e	enum:__anon2
eSuspended	.\freertos\include\task.h	/^	eSuspended,		\/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. *\/$/;"	e	enum:__anon1
eTaskConfirmSleepModeStatus	.\freertos\tasks.c	/^	eSleepModeStatus eTaskConfirmSleepModeStatus( void )$/;"	f
eTaskGetState	.\freertos\include\mpu_wrappers.h	85;"	d
eTaskGetState	.\freertos\tasks.c	/^	eTaskState eTaskGetState( TaskHandle_t xTask )$/;"	f
eTaskState	.\freertos\include\task.h	/^} eTaskState;$/;"	t	typeref:enum:__anon1
eTaskStateGet	.\freertos\include\FreeRTOS.h	727;"	d
errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	.\freertos\include\projdefs.h	84;"	d
errQUEUE_BLOCKED	.\freertos\include\projdefs.h	85;"	d
errQUEUE_EMPTY	.\freertos\include\projdefs.h	80;"	d
errQUEUE_FULL	.\freertos\include\projdefs.h	81;"	d
errQUEUE_YIELD	.\freertos\include\projdefs.h	86;"	d
eventCLEAR_EVENTS_ON_EXIT_BIT	.\freertos\event_groups.c	103;"	d	file:
eventCLEAR_EVENTS_ON_EXIT_BIT	.\freertos\event_groups.c	98;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	.\freertos\event_groups.c	101;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	.\freertos\event_groups.c	106;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	.\freertos\event_groups.c	104;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	.\freertos\event_groups.c	99;"	d	file:
eventWAIT_FOR_ALL_BITS	.\freertos\event_groups.c	100;"	d	file:
eventWAIT_FOR_ALL_BITS	.\freertos\event_groups.c	105;"	d	file:
head	.\CircularBuffer.h	/^	unsigned int head;$/;"	m	struct:CircularBuffer
head	.\CircularBuffer.h	/^	unsigned int head;$/;"	m	struct:CircularBufferLockable
head	.\ringbuf.h	/^	unsigned int head;$/;"	m	struct:_atomic_ringbuf_t
head	.\ringbuf.h	/^	unsigned int head;$/;"	m	struct:_ringbuf_t
heapADJUSTED_HEAP_SIZE	.\freertos\portable\memang\heap_4.c	93;"	d	file:
heapBITS_PER_BYTE	.\freertos\portable\memang\heap_4.c	90;"	d	file:
heapMINIMUM_BLOCK_SIZE	.\freertos\portable\memang\heap_4.c	87;"	d	file:
heapSTRUCT_SIZE	.\freertos\portable\memang\heap_4.c	/^static const uint16_t heapSTRUCT_SIZE	= ( ( sizeof ( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );$/;"	v	file:
init_atomic_ringbuf	.\ringbuf.c	/^init_atomic_ringbuf(atomic_ringbuf_t *c, unsigned char *buffer, unsigned int buffer_size)$/;"	f
init_consumer_task	.\consumer_task.c	/^init_consumer_task(void *pvParameters)$/;"	f
init_producer_task	.\producer_task.c	/^init_producer_task(void *pvParameters)$/;"	f
init_ringbuf	.\ringbuf.c	/^init_ringbuf(ringbuf_t *c, unsigned char *buffer, unsigned int buffer_size)$/;"	f
length	.\CircularBuffer.h	/^	size_t length;$/;"	m	struct:CircularBuffer
length	.\CircularBuffer.h	/^	size_t length;$/;"	m	struct:CircularBufferLockable
length	.\ringbuf.h	/^	size_t length;$/;"	m	struct:_atomic_ringbuf_t
length	.\ringbuf.h	/^	size_t length;$/;"	m	struct:_ringbuf_t
listCURRENT_LIST_LENGTH	.\freertos\include\list.h	246;"	d
listGET_END_MARKER	.\freertos\include\list.h	232;"	d
listGET_HEAD_ENTRY	.\freertos\include\list.h	216;"	d
listGET_ITEM_VALUE_OF_HEAD_ENTRY	.\freertos\include\list.h	208;"	d
listGET_LIST_ITEM_OWNER	.\freertos\include\list.h	180;"	d
listGET_LIST_ITEM_VALUE	.\freertos\include\list.h	199;"	d
listGET_NEXT	.\freertos\include\list.h	224;"	d
listGET_OWNER_OF_HEAD_ENTRY	.\freertos\include\list.h	298;"	d
listGET_OWNER_OF_NEXT_ENTRY	.\freertos\include\list.h	268;"	d
listIS_CONTAINED_WITHIN	.\freertos\include\list.h	309;"	d
listLIST_IS_EMPTY	.\freertos\include\list.h	241;"	d
listLIST_IS_INITIALISED	.\freertos\include\list.h	324;"	d
listLIST_ITEM_CONTAINER	.\freertos\include\list.h	317;"	d
listSET_LIST_ITEM_OWNER	.\freertos\include\list.h	171;"	d
listSET_LIST_ITEM_VALUE	.\freertos\include\list.h	189;"	d
lock_mutex	.\Barrier.h	/^	xSemaphoreHandle lock_mutex;$/;"	m	struct:Barrier
lock_mutex	.\CircularBuffer.h	/^	xSemaphoreHandle lock_mutex;$/;"	m	struct:CircularBufferLockable
lock_mutex	.\barcnt.h	/^	xSemaphoreHandle lock_mutex;$/;"	m	struct:_barcnt_t
lock_mutex	.\ringbuf.h	/^	xSemaphoreHandle lock_mutex;$/;"	m	struct:_atomic_ringbuf_t
main	.\main.c	/^int main( void )$/;"	f
mainQUEUE_LENGTH	.\main_app.c	42;"	d	file:
main_app	.\main_app.c	/^void main_app( void )$/;"	f
mtCOVERAGE_TEST_MARKER	.\freertos\include\FreeRTOS.h	717;"	d
pcHead	.\freertos\queue.c	/^	int8_t *pcHead;					\/*< Points to the beginning of the queue storage area. *\/$/;"	m	struct:QueueDefinition	file:
pcName	.\freertos\include\task.h	/^	const char * const pcName;	\/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_PARAMETERS
pcQueueName	.\freertos\queue.c	/^		const char *pcQueueName; \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:
pcReadFrom	.\freertos\queue.c	/^		int8_t *pcReadFrom;			\/*< Points to the last place that a queued item was read from when the structure is used as a queue. *\/$/;"	m	union:QueueDefinition::__anon4	file:
pcTail	.\freertos\queue.c	/^	int8_t *pcTail;					\/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. *\/$/;"	m	struct:QueueDefinition	file:
pcTaskGetTaskName	.\freertos\tasks.c	/^	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery )$/;"	f
pcTaskName	.\freertos\include\task.h	/^	const char *pcTaskName;			\/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_STATUS
pcTaskName	.\freertos\tasks.c	/^	char				pcTaskName[ configMAX_TASK_NAME_LEN ];\/*< Descriptive name given to the task when created.  Facilitates debugging only. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tskTaskControlBlock	file:
pcTimerName	.\freertos\timers.c	/^	const char				*pcTimerName;		\/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tmrTimerControl	file:
pcWriteTo	.\freertos\queue.c	/^	int8_t *pcWriteTo;				\/*< Points to the free next place in the storage area. *\/$/;"	m	struct:QueueDefinition	file:
pdFAIL	.\freertos\include\projdefs.h	79;"	d
pdFALSE	.\freertos\include\projdefs.h	75;"	d
pdPASS	.\freertos\include\projdefs.h	78;"	d
pdTASK_CODE	.\freertos\include\FreeRTOS.h	746;"	d
pdTASK_HOOK_CODE	.\freertos\include\FreeRTOS.h	740;"	d
pdTRUE	.\freertos\include\projdefs.h	76;"	d
portASSERT_IF_INTERRUPT_PRIORITY_INVALID	.\freertos\include\FreeRTOS.h	709;"	d
portBASE_TYPE	.\freertos\portable\mingw\portmacro.h	81;"	d
portBYTE_ALIGNMENT	.\freertos\portable\mingw\portmacro.h	99;"	d
portBYTE_ALIGNMENT_MASK	.\freertos\include\portable.h	328;"	d
portBYTE_ALIGNMENT_MASK	.\freertos\include\portable.h	332;"	d
portBYTE_ALIGNMENT_MASK	.\freertos\include\portable.h	336;"	d
portBYTE_ALIGNMENT_MASK	.\freertos\include\portable.h	340;"	d
portCHAR	.\freertos\portable\mingw\portmacro.h	75;"	d
portCLEAN_UP_TCB	.\freertos\include\FreeRTOS.h	298;"	d
portCLEAN_UP_TCB	.\freertos\portable\mingw\portmacro.h	105;"	d
portCLEAR_INTERRUPT_MASK_FROM_ISR	.\freertos\include\FreeRTOS.h	294;"	d
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS	.\freertos\FreeRTOSConfig.h	113;"	d
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS	.\freertos\include\FreeRTOS.h	637;"	d
portCRITICAL_NESTING_IN_TCB	.\freertos\include\FreeRTOS.h	229;"	d
portDISABLE_INTERRUPTS	.\freertos\portable\mingw\portmacro.h	107;"	d
portDOUBLE	.\freertos\portable\mingw\portmacro.h	77;"	d
portENABLE_INTERRUPTS	.\freertos\portable\mingw\portmacro.h	108;"	d
portENTER_CRITICAL	.\freertos\portable\mingw\portmacro.h	114;"	d
portEXIT_CRITICAL	.\freertos\portable\mingw\portmacro.h	115;"	d
portFLOAT	.\freertos\portable\mingw\portmacro.h	76;"	d
portGET_HIGHEST_PRIORITY	.\freertos\portable\mingw\portmacro.h	132;"	d
portGET_HIGHEST_PRIORITY	.\freertos\portable\mingw\portmacro.h	140;"	d
portGET_RUN_TIME_COUNTER_VALUE	.\freertos\FreeRTOSConfig.h	114;"	d
portINTERRUPT_TICK	.\freertos\portable\mingw\portmacro.h	156;"	d
portINTERRUPT_YIELD	.\freertos\portable\mingw\portmacro.h	155;"	d
portLONG	.\freertos\portable\mingw\portmacro.h	78;"	d
portMAX_DELAY	.\freertos\portable\mingw\portmacro.h	90;"	d
portMAX_DELAY	.\freertos\portable\mingw\portmacro.h	93;"	d
portMAX_INTERRUPTS	.\freertos\portable\mingw\port.c	77;"	d	file:
portNO_CRITICAL_NESTING	.\freertos\portable\mingw\port.c	78;"	d	file:
portNUM_CONFIGURABLE_REGIONS	.\freertos\include\portable.h	348;"	d
portPOINTER_SIZE_TYPE	.\freertos\include\FreeRTOS.h	319;"	d
portPRE_TASK_DELETE_HOOK	.\freertos\include\FreeRTOS.h	302;"	d
portPRE_TASK_DELETE_HOOK	.\freertos\portable\mingw\portmacro.h	106;"	d
portPRIVILEGE_BIT	.\freertos\include\FreeRTOS.h	645;"	d
portRECORD_READY_PRIORITY	.\freertos\portable\mingw\portmacro.h	125;"	d
portRESET_READY_PRIORITY	.\freertos\portable\mingw\portmacro.h	126;"	d
portRESET_READY_PRIORITY	.\freertos\tasks.c	302;"	d	file:
portSETUP_TCB	.\freertos\include\FreeRTOS.h	306;"	d
portSET_INTERRUPT_MASK_FROM_ISR	.\freertos\include\FreeRTOS.h	290;"	d
portSHORT	.\freertos\portable\mingw\portmacro.h	79;"	d
portSTACK_GROWTH	.\freertos\portable\mingw\portmacro.h	97;"	d
portSTACK_TYPE	.\freertos\portable\mingw\portmacro.h	80;"	d
portSUPPRESS_TICKS_AND_SLEEP	.\freertos\include\FreeRTOS.h	661;"	d
portTASK_FUNCTION	.\freertos\portable\mingw\portmacro.h	152;"	d
portTASK_FUNCTION	.\freertos\tasks.c	/^static portTASK_FUNCTION( prvIdleTask, pvParameters )$/;"	f	file:
portTASK_FUNCTION_PROTO	.\freertos\portable\mingw\portmacro.h	151;"	d
portTASK_USES_FLOATING_POINT	.\freertos\include\FreeRTOS.h	689;"	d
portTICK_PERIOD_MS	.\freertos\portable\mingw\portmacro.h	98;"	d
portTICK_RATE_MS	.\freertos\include\FreeRTOS.h	741;"	d
portTickType	.\freertos\include\FreeRTOS.h	728;"	d
portUSING_MPU_WRAPPERS	.\freertos\include\mpu_wrappers.h	146;"	d
portYIELD	.\freertos\portable\mingw\portmacro.h	101;"	d
portYIELD_WITHIN_API	.\freertos\include\FreeRTOS.h	649;"	d
prvAddCoRoutineToReadyQueue	.\freertos\croutine.c	102;"	d	file:
prvAddCurrentTaskToDelayedList	.\freertos\tasks.c	/^static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )$/;"	f	file:
prvAddTaskToReadyList	.\freertos\tasks.c	364;"	d	file:
prvAllocateTCBAndStack	.\freertos\tasks.c	/^static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )$/;"	f	file:
prvCheckDelayedList	.\freertos\croutine.c	/^static void prvCheckDelayedList( void )$/;"	f	file:
prvCheckForValidListAndQueue	.\freertos\timers.c	/^static void prvCheckForValidListAndQueue( void )$/;"	f	file:
prvCheckPendingReadyList	.\freertos\croutine.c	/^static void prvCheckPendingReadyList( void )$/;"	f	file:
prvCheckTasksWaitingTermination	.\freertos\tasks.c	/^static void prvCheckTasksWaitingTermination( void )$/;"	f	file:
prvConsumerTask	.\consumer_task.c	/^prvConsumerTask(void *pvParameters)$/;"	f	file:
prvCopyDataFromQueue	.\freertos\queue.c	/^static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )$/;"	f	file:
prvCopyDataToQueue	.\freertos\queue.c	/^static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )$/;"	f	file:
prvDeleteTCB	.\freertos\tasks.c	/^	static void prvDeleteTCB( TCB_t *pxTCB )$/;"	f	file:
prvEndProcess	.\freertos\portable\mingw\port.c	/^static BOOL WINAPI prvEndProcess( DWORD dwCtrlType )$/;"	f	file:
prvGetExpectedIdleTime	.\freertos\tasks.c	/^	static TickType_t prvGetExpectedIdleTime( void )$/;"	f	file:
prvGetNextExpireTime	.\freertos\timers.c	/^static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )$/;"	f	file:
prvGetTCBFromHandle	.\freertos\tasks.c	376;"	d	file:
prvHeapInit	.\freertos\portable\memang\heap_4.c	/^static void prvHeapInit( void )$/;"	f	file:
prvInitialiseCoRoutineLists	.\freertos\croutine.c	/^static void prvInitialiseCoRoutineLists( void )$/;"	f	file:
prvInitialiseTCBVariables	.\freertos\tasks.c	/^static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	file:
prvInitialiseTaskLists	.\freertos\tasks.c	/^static void prvInitialiseTaskLists( void )$/;"	f	file:
prvInsertBlockIntoFreeList	.\freertos\portable\memang\heap_4.c	/^static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )$/;"	f	file:
prvInsertTimerInActiveList	.\freertos\timers.c	/^static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )$/;"	f	file:
prvIsQueueEmpty	.\freertos\queue.c	/^static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )$/;"	f	file:
prvIsQueueFull	.\freertos\queue.c	/^static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )$/;"	f	file:
prvListTaskWithinSingleList	.\freertos\tasks.c	/^	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )$/;"	f	file:
prvLockQueue	.\freertos\queue.c	240;"	d	file:
prvNotifyQueueSetContainer	.\freertos\queue.c	/^	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )$/;"	f	file:
prvProcessExpiredTimer	.\freertos\timers.c	/^static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )$/;"	f	file:
prvProcessReceivedCommands	.\freertos\timers.c	/^static void	prvProcessReceivedCommands( void )$/;"	f	file:
prvProcessSimulatedInterrupts	.\freertos\portable\mingw\port.c	/^static void prvProcessSimulatedInterrupts( void )$/;"	f	file:
prvProcessTickInterrupt	.\freertos\portable\mingw\port.c	/^static uint32_t prvProcessTickInterrupt( void )$/;"	f	file:
prvProcessTimerOrBlockTask	.\freertos\timers.c	/^static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )$/;"	f	file:
prvProcessYieldInterrupt	.\freertos\portable\mingw\port.c	/^static uint32_t prvProcessYieldInterrupt( void )$/;"	f	file:
prvProducerTask	.\producer_task.c	/^prvProducerTask(void *pvParameters)$/;"	f	file:
prvResetNextTaskUnblockTime	.\freertos\tasks.c	/^static void prvResetNextTaskUnblockTime( void )$/;"	f	file:
prvSampleTimeNow	.\freertos\timers.c	/^static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )$/;"	f	file:
prvSimulatedPeripheralTimer	.\freertos\portable\mingw\port.c	/^static DWORD WINAPI prvSimulatedPeripheralTimer( LPVOID lpParameter )$/;"	f	file:
prvSwitchTimerLists	.\freertos\timers.c	/^static void prvSwitchTimerLists( void )$/;"	f	file:
prvTaskCheckFreeStackSpace	.\freertos\tasks.c	/^	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )$/;"	f	file:
prvTaskIsTaskSuspended	.\freertos\tasks.c	/^	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )$/;"	f	file:
prvTestWaitCondition	.\freertos\event_groups.c	/^static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )$/;"	f	file:
prvTimerTask	.\freertos\timers.c	/^static void prvTimerTask( void *pvParameters )$/;"	f	file:
prvUnlockQueue	.\freertos\queue.c	/^static void prvUnlockQueue( Queue_t * const pxQueue )$/;"	f	file:
puxStackBuffer	.\freertos\include\task.h	/^	StackType_t *puxStackBuffer;$/;"	m	struct:xTASK_PARAMETERS
pvBaseAddress	.\freertos\include\task.h	/^	void *pvBaseAddress;$/;"	m	struct:xMEMORY_REGION
pvContainer	.\freertos\include\list.h	/^	void * configLIST_VOLATILE pvContainer;				\/*< Pointer to the list in which this list item is placed (if any). *\/$/;"	m	struct:xLIST_ITEM
pvInterruptEvent	.\freertos\portable\mingw\port.c	/^static void *pvInterruptEvent = NULL;$/;"	v	file:
pvInterruptEventMutex	.\freertos\portable\mingw\port.c	/^static void *pvInterruptEventMutex = NULL;$/;"	v	file:
pvOwner	.\freertos\include\list.h	/^	void * pvOwner;										\/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. *\/$/;"	m	struct:xLIST_ITEM
pvParameter1	.\freertos\timers.c	/^	void *pvParameter1;						\/* << The value that will be used as the callback functions first parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:
pvParameters	.\freertos\include\task.h	/^	void *pvParameters;$/;"	m	struct:xTASK_PARAMETERS
pvPortMalloc	.\freertos\include\mpu_wrappers.h	121;"	d
pvPortMalloc	.\freertos\portable\memang\heap_4.c	/^void *pvPortMalloc( size_t xWantedSize )$/;"	f
pvPortMallocAligned	.\freertos\include\FreeRTOS.h	653;"	d
pvTaskCode	.\freertos\include\task.h	/^	TaskFunction_t pvTaskCode;$/;"	m	struct:xTASK_PARAMETERS
pvThread	.\freertos\portable\mingw\port.c	/^	void *pvThread;$/;"	m	struct:__anon3	file:
pvTimerGetTimerID	.\freertos\timers.c	/^void *pvTimerGetTimerID( const TimerHandle_t xTimer )$/;"	f
pvTimerID	.\freertos\timers.c	/^	void 					*pvTimerID;			\/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. *\/$/;"	m	struct:tmrTimerControl	file:
pxCallbackFunction	.\freertos\timers.c	/^	PendedFunction_t	pxCallbackFunction;	\/* << The callback function to execute. *\/$/;"	m	struct:tmrCallbackParameters	file:
pxCallbackFunction	.\freertos\timers.c	/^	TimerCallbackFunction_t	pxCallbackFunction;	\/*<< The function that will be called when the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:
pxCoRoutineFunction	.\freertos\include\croutine.h	/^	crCOROUTINE_CODE 	pxCoRoutineFunction;$/;"	m	struct:corCoRoutineControlBlock
pxCurrentCoRoutine	.\freertos\croutine.c	/^CRCB_t * pxCurrentCoRoutine = NULL;$/;"	v
pxCurrentTCB	.\freertos\tasks.c	/^PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;$/;"	v
pxCurrentTimerList	.\freertos\timers.c	/^PRIVILEGED_DATA static List_t *pxCurrentTimerList;$/;"	v	file:
pxDelayedCoRoutineList	.\freertos\croutine.c	/^static List_t * pxDelayedCoRoutineList;									\/*< Points to the delayed co-routine list currently being used. *\/$/;"	v	file:
pxDelayedTaskList	.\freertos\tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				\/*< Points to the delayed task list currently being used. *\/$/;"	v	file:
pxEnd	.\freertos\portable\memang\heap_4.c	/^static BlockLink_t xStart, *pxEnd = NULL;$/;"	v	file:
pxEndOfStack	.\freertos\tasks.c	/^		StackType_t		*pxEndOfStack;		\/*< Points to the end of the stack on architectures where the stack grows up from low memory. *\/$/;"	m	struct:tskTaskControlBlock	file:
pxISR	.\freertos\include\portable.h	/^	typedef void ( __interrupt __far *pxISR )();$/;"	t
pxISR	.\freertos\include\portable.h	/^    typedef void ( __interrupt __far *pxISR )();$/;"	t
pxIndex	.\freertos\include\list.h	/^	ListItem_t * configLIST_VOLATILE pxIndex;		\/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). *\/$/;"	m	struct:xLIST
pxMutexHolder	.\freertos\queue.c	104;"	d	file:
pxNext	.\freertos\include\list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		\/*< Pointer to the next ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE
pxNext	.\freertos\include\list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxNext;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE
pxNextFreeBlock	.\freertos\portable\memang\heap_4.c	/^	struct A_BLOCK_LINK *pxNextFreeBlock;	\/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:
pxOverflowDelayedCoRoutineList	.\freertos\croutine.c	/^static List_t * pxOverflowDelayedCoRoutineList;							\/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowDelayedTaskList	.\freertos\tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		\/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowTimerList	.\freertos\timers.c	/^PRIVILEGED_DATA static List_t *pxOverflowTimerList;$/;"	v	file:
pxPortInitialiseStack	.\freertos\portable\mingw\port.c	/^StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )$/;"	f
pxPrevious	.\freertos\include\list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	\/*< Pointer to the previous ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE
pxPrevious	.\freertos\include\list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE
pxQueueSetContainer	.\freertos\queue.c	/^		struct QueueDefinition *pxQueueSetContainer;$/;"	m	struct:QueueDefinition	typeref:struct:QueueDefinition::QueueDefinition	file:
pxReadyCoRoutineLists	.\freertos\croutine.c	/^static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	\/*< Prioritised ready co-routines. *\/$/;"	v	file:
pxReadyTasksLists	.\freertos\tasks.c	/^PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];\/*< Prioritised ready tasks. *\/$/;"	v	file:
pxStack	.\freertos\tasks.c	/^	StackType_t			*pxStack;			\/*< Points to the start of the stack. *\/$/;"	m	struct:tskTaskControlBlock	file:
pxTaskTag	.\freertos\tasks.c	/^		TaskHookFunction_t pxTaskTag;$/;"	m	struct:tskTaskControlBlock	file:
pxTimer	.\freertos\timers.c	/^	Timer_t *			pxTimer;			\/*<< The timer to which the command will be applied. *\/$/;"	m	struct:tmrTimerParameters	file:
pxTopOfStack	.\freertos\tasks.c	/^	volatile StackType_t	*pxTopOfStack;	\/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:
queue	.\consumer_task.h	/^	QueueHandle_t queue;$/;"	m	struct:xConsumerTaskInitParams
queue	.\consumer_task.h	/^	QueueHandle_t queue;$/;"	m	struct:xConsumerTaskParams
queue	.\producer_task.h	/^	QueueHandle_t* queue;$/;"	m	struct:xProducerTaskInitParams
queue	.\producer_task.h	/^	QueueHandle_t* queue;$/;"	m	struct:xProducerTaskParams
queueLOCKED_UNMODIFIED	.\freertos\queue.c	91;"	d	file:
queueMUTEX_GIVE_BLOCK_TIME	.\freertos\queue.c	111;"	d	file:
queueOVERWRITE	.\freertos\include\queue.h	103;"	d
queueQUEUE_IS_MUTEX	.\freertos\queue.c	106;"	d	file:
queueQUEUE_TYPE_BASE	.\freertos\include\queue.h	106;"	d
queueQUEUE_TYPE_BINARY_SEMAPHORE	.\freertos\include\queue.h	110;"	d
queueQUEUE_TYPE_COUNTING_SEMAPHORE	.\freertos\include\queue.h	109;"	d
queueQUEUE_TYPE_MUTEX	.\freertos\include\queue.h	108;"	d
queueQUEUE_TYPE_RECURSIVE_MUTEX	.\freertos\include\queue.h	111;"	d
queueQUEUE_TYPE_SET	.\freertos\include\queue.h	107;"	d
queueSEMAPHORE_QUEUE_ITEM_LENGTH	.\freertos\queue.c	110;"	d	file:
queueSEND_TO_BACK	.\freertos\include\queue.h	101;"	d
queueSEND_TO_FRONT	.\freertos\include\queue.h	102;"	d
queueUNLOCKED	.\freertos\queue.c	90;"	d	file:
queueYIELD_IF_USING_PREEMPTION	.\freertos\queue.c	116;"	d	file:
queueYIELD_IF_USING_PREEMPTION	.\freertos\queue.c	118;"	d	file:
queuemsg_t	.\queuemsg.h	/^} queuemsg_t;$/;"	t	typeref:struct:_queuemsg_t
read_atomic_ringbuf	.\ringbuf.c	/^read_atomic_ringbuf(atomic_ringbuf_t *c, unsigned char *dataOut, unsigned int length){$/;"	f
read_ringbuf	.\ringbuf.c	/^int read_ringbuf(ringbuf_t *c, unsigned char *dataOut, unsigned int length)$/;"	f
ringbuf_t	.\ringbuf.h	/^} ringbuf_t;$/;"	t	typeref:struct:_ringbuf_t
semBINARY_SEMAPHORE_QUEUE_LENGTH	.\freertos\include\semphr.h	77;"	d
semGIVE_BLOCK_TIME	.\freertos\include\semphr.h	79;"	d
semSEMAPHORE_QUEUE_ITEM_LENGTH	.\freertos\include\semphr.h	78;"	d
set_barcnt	.\barcnt.c	/^int set_barcnt(barcnt_t *b, unsigned int count)$/;"	f
set_barrier	.\Barrier.c	/^int set_barrier(Barrier *b, unsigned int count)$/;"	f
size	.\CircularBuffer.h	/^	unsigned int size;$/;"	m	struct:CircularBuffer
size	.\CircularBuffer.h	/^	unsigned int size;$/;"	m	struct:CircularBufferLockable
size	.\ringbuf.h	/^	unsigned int size;$/;"	m	struct:_atomic_ringbuf_t
size	.\ringbuf.h	/^	unsigned int size;$/;"	m	struct:_ringbuf_t
static	.\freertos\croutine.c	75;"	d	file:
static	.\freertos\tasks.c	181;"	d	file:
tail	.\CircularBuffer.h	/^	unsigned int tail;$/;"	m	struct:CircularBuffer
tail	.\CircularBuffer.h	/^	unsigned int tail;$/;"	m	struct:CircularBufferLockable
tail	.\ringbuf.h	/^	unsigned int tail;$/;"	m	struct:_atomic_ringbuf_t
tail	.\ringbuf.h	/^	unsigned int tail;$/;"	m	struct:_ringbuf_t
taskDISABLE_INTERRUPTS	.\freertos\include\task.h	226;"	d
taskENABLE_INTERRUPTS	.\freertos\include\task.h	236;"	d
taskENTER_CRITICAL	.\freertos\include\task.h	202;"	d
taskEVENT_LIST_ITEM_VALUE_IN_USE	.\freertos\tasks.c	387;"	d	file:
taskEVENT_LIST_ITEM_VALUE_IN_USE	.\freertos\tasks.c	389;"	d	file:
taskEXIT_CRITICAL	.\freertos\include\task.h	216;"	d
taskFIRST_CHECK_FOR_STACK_OVERFLOW	.\freertos\include\StackMacros.h	106;"	d
taskFIRST_CHECK_FOR_STACK_OVERFLOW	.\freertos\include\StackMacros.h	121;"	d
taskFIRST_CHECK_FOR_STACK_OVERFLOW	.\freertos\include\StackMacros.h	88;"	d
taskRECORD_READY_PRIORITY	.\freertos\tasks.c	272;"	d	file:
taskRECORD_READY_PRIORITY	.\freertos\tasks.c	311;"	d	file:
taskRESET_READY_PRIORITY	.\freertos\tasks.c	301;"	d	file:
taskRESET_READY_PRIORITY	.\freertos\tasks.c	330;"	d	file:
taskSCHEDULER_NOT_STARTED	.\freertos\include\task.h	242;"	d
taskSCHEDULER_RUNNING	.\freertos\include\task.h	243;"	d
taskSCHEDULER_SUSPENDED	.\freertos\include\task.h	241;"	d
taskSECOND_CHECK_FOR_STACK_OVERFLOW	.\freertos\include\StackMacros.h	136;"	d
taskSECOND_CHECK_FOR_STACK_OVERFLOW	.\freertos\include\StackMacros.h	157;"	d
taskSECOND_CHECK_FOR_STACK_OVERFLOW	.\freertos\include\StackMacros.h	89;"	d
taskSECOND_CHECK_FOR_STACK_OVERFLOW	.\freertos\include\StackMacros.h	98;"	d
taskSELECT_HIGHEST_PRIORITY_TASK	.\freertos\tasks.c	282;"	d	file:
taskSELECT_HIGHEST_PRIORITY_TASK	.\freertos\tasks.c	315;"	d	file:
taskSWITCH_DELAYED_LISTS	.\freertos\tasks.c	344;"	d	file:
taskYIELD	.\freertos\include\task.h	188;"	d
taskYIELD_IF_USING_PREEMPTION	.\freertos\tasks.c	110;"	d	file:
taskYIELD_IF_USING_PREEMPTION	.\freertos\tasks.c	112;"	d	file:
tmrCOMMAND_CHANGE_PERIOD	.\freertos\include\timers.h	98;"	d
tmrCOMMAND_CHANGE_PERIOD_FROM_ISR	.\freertos\include\timers.h	105;"	d
tmrCOMMAND_DELETE	.\freertos\include\timers.h	99;"	d
tmrCOMMAND_EXECUTE_CALLBACK	.\freertos\include\timers.h	93;"	d
tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR	.\freertos\include\timers.h	92;"	d
tmrCOMMAND_RESET	.\freertos\include\timers.h	96;"	d
tmrCOMMAND_RESET_FROM_ISR	.\freertos\include\timers.h	103;"	d
tmrCOMMAND_START	.\freertos\include\timers.h	95;"	d
tmrCOMMAND_START_DONT_TRACE	.\freertos\include\timers.h	94;"	d
tmrCOMMAND_START_FROM_ISR	.\freertos\include\timers.h	102;"	d
tmrCOMMAND_STOP	.\freertos\include\timers.h	97;"	d
tmrCOMMAND_STOP_FROM_ISR	.\freertos\include\timers.h	104;"	d
tmrCallbackParameters	.\freertos\timers.c	/^typedef struct tmrCallbackParameters$/;"	s	file:
tmrFIRST_FROM_ISR_COMMAND	.\freertos\include\timers.h	101;"	d
tmrNO_DELAY	.\freertos\timers.c	97;"	d	file:
tmrTIMER_CALLBACK	.\freertos\include\FreeRTOS.h	745;"	d
tmrTimerControl	.\freertos\timers.c	/^typedef struct tmrTimerControl$/;"	s	file:
tmrTimerParameters	.\freertos\timers.c	/^typedef struct tmrTimerParameters$/;"	s	file:
tmrTimerQueueMessage	.\freertos\timers.c	/^typedef struct tmrTimerQueueMessage$/;"	s	file:
traceBLOCKING_ON_QUEUE_RECEIVE	.\freertos\include\FreeRTOS.h	385;"	d
traceBLOCKING_ON_QUEUE_SEND	.\freertos\include\FreeRTOS.h	393;"	d
traceCREATE_COUNTING_SEMAPHORE	.\freertos\include\FreeRTOS.h	439;"	d
traceCREATE_COUNTING_SEMAPHORE_FAILED	.\freertos\include\FreeRTOS.h	443;"	d
traceCREATE_MUTEX	.\freertos\include\FreeRTOS.h	415;"	d
traceCREATE_MUTEX_FAILED	.\freertos\include\FreeRTOS.h	419;"	d
traceEND	.\freertos\include\FreeRTOS.h	332;"	d
traceEVENT_GROUP_CLEAR_BITS	.\freertos\include\FreeRTOS.h	587;"	d
traceEVENT_GROUP_CLEAR_BITS_FROM_ISR	.\freertos\include\FreeRTOS.h	591;"	d
traceEVENT_GROUP_CREATE	.\freertos\include\FreeRTOS.h	563;"	d
traceEVENT_GROUP_CREATE_FAILED	.\freertos\include\FreeRTOS.h	567;"	d
traceEVENT_GROUP_DELETE	.\freertos\include\FreeRTOS.h	603;"	d
traceEVENT_GROUP_SET_BITS	.\freertos\include\FreeRTOS.h	595;"	d
traceEVENT_GROUP_SET_BITS_FROM_ISR	.\freertos\include\FreeRTOS.h	599;"	d
traceEVENT_GROUP_SYNC_BLOCK	.\freertos\include\FreeRTOS.h	571;"	d
traceEVENT_GROUP_SYNC_END	.\freertos\include\FreeRTOS.h	575;"	d
traceEVENT_GROUP_WAIT_BITS_BLOCK	.\freertos\include\FreeRTOS.h	579;"	d
traceEVENT_GROUP_WAIT_BITS_END	.\freertos\include\FreeRTOS.h	583;"	d
traceFREE	.\freertos\include\FreeRTOS.h	559;"	d
traceGIVE_MUTEX_RECURSIVE	.\freertos\include\FreeRTOS.h	423;"	d
traceGIVE_MUTEX_RECURSIVE_FAILED	.\freertos\include\FreeRTOS.h	427;"	d
traceINCREASE_TICK_COUNT	.\freertos\include\FreeRTOS.h	344;"	d
traceLOW_POWER_IDLE_BEGIN	.\freertos\include\FreeRTOS.h	349;"	d
traceLOW_POWER_IDLE_END	.\freertos\include\FreeRTOS.h	354;"	d
traceMALLOC	.\freertos\include\FreeRTOS.h	555;"	d
traceMOVED_TASK_TO_READY_STATE	.\freertos\include\FreeRTOS.h	403;"	d
tracePEND_FUNC_CALL	.\freertos\include\FreeRTOS.h	607;"	d
tracePEND_FUNC_CALL_FROM_ISR	.\freertos\include\FreeRTOS.h	611;"	d
traceQUEUE_CREATE	.\freertos\include\FreeRTOS.h	407;"	d
traceQUEUE_CREATE_FAILED	.\freertos\include\FreeRTOS.h	411;"	d
traceQUEUE_DELETE	.\freertos\include\FreeRTOS.h	491;"	d
traceQUEUE_PEEK	.\freertos\include\FreeRTOS.h	459;"	d
traceQUEUE_PEEK_FROM_ISR	.\freertos\include\FreeRTOS.h	463;"	d
traceQUEUE_PEEK_FROM_ISR_FAILED	.\freertos\include\FreeRTOS.h	487;"	d
traceQUEUE_RECEIVE	.\freertos\include\FreeRTOS.h	455;"	d
traceQUEUE_RECEIVE_FAILED	.\freertos\include\FreeRTOS.h	467;"	d
traceQUEUE_RECEIVE_FROM_ISR	.\freertos\include\FreeRTOS.h	479;"	d
traceQUEUE_RECEIVE_FROM_ISR_FAILED	.\freertos\include\FreeRTOS.h	483;"	d
traceQUEUE_REGISTRY_ADD	.\freertos\include\FreeRTOS.h	615;"	d
traceQUEUE_SEND	.\freertos\include\FreeRTOS.h	447;"	d
traceQUEUE_SEND_FAILED	.\freertos\include\FreeRTOS.h	451;"	d
traceQUEUE_SEND_FROM_ISR	.\freertos\include\FreeRTOS.h	471;"	d
traceQUEUE_SEND_FROM_ISR_FAILED	.\freertos\include\FreeRTOS.h	475;"	d
traceSTART	.\freertos\include\FreeRTOS.h	326;"	d
traceTAKE_MUTEX_RECURSIVE	.\freertos\include\FreeRTOS.h	431;"	d
traceTAKE_MUTEX_RECURSIVE_FAILED	.\freertos\include\FreeRTOS.h	435;"	d
traceTASK_CREATE	.\freertos\include\FreeRTOS.h	495;"	d
traceTASK_CREATE_FAILED	.\freertos\include\FreeRTOS.h	499;"	d
traceTASK_DELAY	.\freertos\include\FreeRTOS.h	511;"	d
traceTASK_DELAY_UNTIL	.\freertos\include\FreeRTOS.h	507;"	d
traceTASK_DELETE	.\freertos\include\FreeRTOS.h	503;"	d
traceTASK_INCREMENT_TICK	.\freertos\include\FreeRTOS.h	531;"	d
traceTASK_PRIORITY_DISINHERIT	.\freertos\include\FreeRTOS.h	377;"	d
traceTASK_PRIORITY_INHERIT	.\freertos\include\FreeRTOS.h	369;"	d
traceTASK_PRIORITY_SET	.\freertos\include\FreeRTOS.h	515;"	d
traceTASK_RESUME	.\freertos\include\FreeRTOS.h	523;"	d
traceTASK_RESUME_FROM_ISR	.\freertos\include\FreeRTOS.h	527;"	d
traceTASK_SUSPEND	.\freertos\include\FreeRTOS.h	519;"	d
traceTASK_SWITCHED_IN	.\freertos\include\FreeRTOS.h	338;"	d
traceTASK_SWITCHED_OUT	.\freertos\include\FreeRTOS.h	360;"	d
traceTIMER_COMMAND_RECEIVED	.\freertos\include\FreeRTOS.h	551;"	d
traceTIMER_COMMAND_SEND	.\freertos\include\FreeRTOS.h	543;"	d
traceTIMER_CREATE	.\freertos\include\FreeRTOS.h	535;"	d
traceTIMER_CREATE_FAILED	.\freertos\include\FreeRTOS.h	539;"	d
traceTIMER_EXPIRED	.\freertos\include\FreeRTOS.h	547;"	d
tskBLOCKED_CHAR	.\freertos\tasks.c	257;"	d	file:
tskCONSUMER_PRIORITY	.\consumer_task.c	44;"	d	file:
tskDELETED_CHAR	.\freertos\tasks.c	259;"	d	file:
tskIDLE_PRIORITY	.\freertos\include\task.h	178;"	d
tskIDLE_STACK_SIZE	.\freertos\tasks.c	105;"	d	file:
tskKERNEL_VERSION_BUILD	.\freertos\include\task.h	87;"	d
tskKERNEL_VERSION_MAJOR	.\freertos\include\task.h	85;"	d
tskKERNEL_VERSION_MINOR	.\freertos\include\task.h	86;"	d
tskKERNEL_VERSION_NUMBER	.\freertos\include\task.h	84;"	d
tskPRODUCER_PRIORITY	.\producer_task.c	48;"	d	file:
tskREADY_CHAR	.\freertos\tasks.c	258;"	d	file:
tskSTACK_FILL_BYTE	.\freertos\tasks.c	252;"	d	file:
tskSUSPENDED_CHAR	.\freertos\tasks.c	260;"	d	file:
tskTCB	.\freertos\tasks.c	/^} tskTCB;$/;"	t	typeref:struct:tskTaskControlBlock	file:
tskTaskControlBlock	.\freertos\tasks.c	/^typedef struct tskTaskControlBlock$/;"	s	file:
u	.\freertos\queue.c	/^	} u;$/;"	m	struct:QueueDefinition	typeref:union:QueueDefinition::__anon4	file:
u	.\freertos\timers.c	/^	} u;$/;"	m	struct:tmrTimerQueueMessage	typeref:union:tmrTimerQueueMessage::__anon5	file:
ucHeap	.\freertos\portable\memang\heap_4.c	/^static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];$/;"	v	file:
ucQueueGetQueueType	.\freertos\queue.c	/^	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )$/;"	f
ucQueueType	.\freertos\queue.c	/^		uint8_t ucQueueType;$/;"	m	struct:QueueDefinition	file:
ulCriticalNesting	.\freertos\portable\mingw\port.c	/^static uint32_t ulCriticalNesting = 9999UL;$/;"	v	file:
ulIsrHandler	.\freertos\portable\mingw\port.c	/^static uint32_t (*ulIsrHandler[ portMAX_INTERRUPTS ])( void ) = { 0 };$/;"	v	file:
ulLengthInBytes	.\freertos\include\task.h	/^	uint32_t ulLengthInBytes;$/;"	m	struct:xMEMORY_REGION
ulParameter2	.\freertos\timers.c	/^	uint32_t ulParameter2;					\/* << The value that will be used as the callback functions second parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:
ulParameters	.\freertos\include\task.h	/^	uint32_t ulParameters;$/;"	m	struct:xMEMORY_REGION
ulPendingInterrupts	.\freertos\portable\mingw\port.c	/^static volatile uint32_t ulPendingInterrupts = 0UL;$/;"	v	file:
ulRunTimeCounter	.\freertos\include\task.h	/^	uint32_t ulRunTimeCounter;		\/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http:\/\/www.freertos.org\/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS
ulRunTimeCounter	.\freertos\tasks.c	/^		uint32_t		ulRunTimeCounter;	\/*< Stores the amount of time the task has spent in the Running state. *\/$/;"	m	struct:tskTaskControlBlock	file:
ulTaskSwitchedInTime	.\freertos\tasks.c	/^	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	\/*< Holds the value of a timer\/counter the last time a task was switched in. *\/$/;"	v	file:
ulTotalRunTime	.\freertos\tasks.c	/^	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		\/*< Holds the total amount of execution time as defined by the run time counter clock. *\/$/;"	v	file:
usStackDepth	.\freertos\include\task.h	/^	uint16_t usStackDepth;$/;"	m	struct:xTASK_PARAMETERS
usStackHighWaterMark	.\freertos\include\task.h	/^	uint16_t usStackHighWaterMark;	\/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. *\/$/;"	m	struct:xTASK_STATUS
uxAutoReload	.\freertos\timers.c	/^	UBaseType_t				uxAutoReload;		\/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. *\/$/;"	m	struct:tmrTimerControl	file:
uxBasePriority	.\freertos\include\task.h	/^	UBaseType_t uxBasePriority;		\/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS
uxBasePriority	.\freertos\tasks.c	/^		UBaseType_t 	uxBasePriority;		\/*< The priority last assigned to the task - used by the priority inheritance mechanism. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxCriticalNesting	.\freertos\tasks.c	/^		UBaseType_t 	uxCriticalNesting; 	\/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxCurrentNumberOfTasks	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;$/;"	v	file:
uxCurrentPriority	.\freertos\include\task.h	/^	UBaseType_t uxCurrentPriority;	\/* The priority at which the task was running (may be inherited) when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS
uxEventBits	.\freertos\event_groups.c	/^	EventBits_t uxEventBits;$/;"	m	struct:xEventGroupDefinition	file:
uxEventGroupGetNumber	.\freertos\event_groups.c	/^	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )$/;"	f
uxEventGroupNumber	.\freertos\event_groups.c	/^		UBaseType_t uxEventGroupNumber;$/;"	m	struct:xEventGroupDefinition	file:
uxIndex	.\freertos\include\croutine.h	/^	UBaseType_t 		uxIndex;			\/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. *\/$/;"	m	struct:corCoRoutineControlBlock
uxItemSize	.\freertos\queue.c	/^	UBaseType_t uxItemSize;			\/*< The size of each items that the queue will hold. *\/$/;"	m	struct:QueueDefinition	file:
uxLength	.\freertos\queue.c	/^	UBaseType_t uxLength;			\/*< The length of the queue defined as the number of items it will hold, not the number of bytes. *\/$/;"	m	struct:QueueDefinition	file:
uxListRemove	.\freertos\list.c	/^UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )$/;"	f
uxMessagesWaiting	.\freertos\queue.c	/^	volatile UBaseType_t uxMessagesWaiting;\/*< The number of items currently in the queue. *\/$/;"	m	struct:QueueDefinition	file:
uxNumberOfItems	.\freertos\include\list.h	/^	configLIST_VOLATILE UBaseType_t uxNumberOfItems;$/;"	m	struct:xLIST
uxPendedTicks	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;$/;"	v	file:
uxPriority	.\freertos\include\croutine.h	/^	UBaseType_t 		uxPriority;			\/*< The priority of the co-routine in relation to other co-routines. *\/$/;"	m	struct:corCoRoutineControlBlock
uxPriority	.\freertos\include\task.h	/^	UBaseType_t uxPriority;$/;"	m	struct:xTASK_PARAMETERS
uxPriority	.\freertos\tasks.c	/^	UBaseType_t			uxPriority;			\/*< The priority of the task.  0 is the lowest priority. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxQueueGetQueueNumber	.\freertos\queue.c	/^	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )$/;"	f
uxQueueMessagesWaiting	.\freertos\include\mpu_wrappers.h	112;"	d
uxQueueMessagesWaiting	.\freertos\queue.c	/^UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )$/;"	f
uxQueueMessagesWaitingFromISR	.\freertos\queue.c	/^UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )$/;"	f
uxQueueNumber	.\freertos\queue.c	/^		UBaseType_t uxQueueNumber;$/;"	m	struct:QueueDefinition	file:
uxQueueSpacesAvailable	.\freertos\queue.c	/^UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )$/;"	f
uxQueueType	.\freertos\queue.c	105;"	d	file:
uxRecursiveCallCount	.\freertos\queue.c	/^		UBaseType_t uxRecursiveCallCount;\/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. *\/$/;"	m	union:QueueDefinition::__anon4	file:
uxSchedulerSuspended	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;$/;"	v	file:
uxState	.\freertos\include\croutine.h	/^	uint16_t 			uxState;			\/*< Used internally by the co-routine implementation. *\/$/;"	m	struct:corCoRoutineControlBlock
uxTCBNumber	.\freertos\tasks.c	/^		UBaseType_t		uxTCBNumber;		\/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxTaskGetNumberOfTasks	.\freertos\include\mpu_wrappers.h	91;"	d
uxTaskGetNumberOfTasks	.\freertos\tasks.c	/^UBaseType_t uxTaskGetNumberOfTasks( void )$/;"	f
uxTaskGetStackHighWaterMark	.\freertos\include\mpu_wrappers.h	97;"	d
uxTaskGetStackHighWaterMark	.\freertos\tasks.c	/^	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )$/;"	f
uxTaskGetSystemState	.\freertos\include\mpu_wrappers.h	101;"	d
uxTaskGetSystemState	.\freertos\tasks.c	/^	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )$/;"	f
uxTaskGetTaskNumber	.\freertos\tasks.c	/^	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )$/;"	f
uxTaskNumber	.\freertos\tasks.c	/^		UBaseType_t  	uxTaskNumber;		\/*< Stores a number specifically for use by third party trace code. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxTaskNumber	.\freertos\tasks.c	/^PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;$/;"	v	file:
uxTaskPriorityGet	.\freertos\include\mpu_wrappers.h	83;"	d
uxTaskPriorityGet	.\freertos\tasks.c	/^	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )$/;"	f
uxTaskResetEventItemValue	.\freertos\tasks.c	/^TickType_t uxTaskResetEventItemValue( void )$/;"	f
uxTasksDeleted	.\freertos\tasks.c	/^	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;$/;"	v	file:
uxTimerNumber	.\freertos\timers.c	/^		UBaseType_t			uxTimerNumber;		\/*<< An ID assigned by trace tools such as FreeRTOS+Trace *\/$/;"	m	struct:tmrTimerControl	file:
uxTopCoRoutineReadyPriority	.\freertos\croutine.c	/^static UBaseType_t uxTopCoRoutineReadyPriority = 0;$/;"	v	file:
uxTopReadyPriority	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;$/;"	v	file:
vApplicationIdleHook	.\main.c	/^void vApplicationIdleHook( void )$/;"	f
vApplicationMallocFailedHook	.\main.c	/^void vApplicationMallocFailedHook( void )$/;"	f
vApplicationStackOverflowHook	.\main.c	/^void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )$/;"	f
vApplicationTickHook	.\main.c	/^void vApplicationTickHook( void )$/;"	f
vAssertCalled	.\main.c	/^void vAssertCalled( unsigned long ulLine, const char * const pcFileName )$/;"	f
vCoRoutineAddToDelayedList	.\freertos\croutine.c	/^void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )$/;"	f
vCoRoutineSchedule	.\freertos\croutine.c	/^void vCoRoutineSchedule( void )$/;"	f
vEventGroupDelete	.\freertos\event_groups.c	/^void vEventGroupDelete( EventGroupHandle_t xEventGroup )$/;"	f
vEventGroupSetBitsCallback	.\freertos\event_groups.c	/^void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )$/;"	f
vListInitialise	.\freertos\list.c	/^void vListInitialise( List_t * const pxList )$/;"	f
vListInitialiseItem	.\freertos\list.c	/^void vListInitialiseItem( ListItem_t * const pxItem )$/;"	f
vListInsert	.\freertos\list.c	/^void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )$/;"	f
vListInsertEnd	.\freertos\list.c	/^void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )$/;"	f
vPortCloseRunningThread	.\freertos\portable\mingw\port.c	/^void vPortCloseRunningThread( void *pvTaskToDelete, volatile BaseType_t *pxPendYield )$/;"	f
vPortDeleteThread	.\freertos\portable\mingw\port.c	/^void vPortDeleteThread( void *pvTaskToDelete )$/;"	f
vPortEndScheduler	.\freertos\portable\mingw\port.c	/^void vPortEndScheduler( void )$/;"	f
vPortEnterCritical	.\freertos\portable\mingw\port.c	/^void vPortEnterCritical( void )$/;"	f
vPortExitCritical	.\freertos\portable\mingw\port.c	/^void vPortExitCritical( void )$/;"	f
vPortFree	.\freertos\include\mpu_wrappers.h	122;"	d
vPortFree	.\freertos\portable\memang\heap_4.c	/^void vPortFree( void *pv )$/;"	f
vPortFreeAligned	.\freertos\include\FreeRTOS.h	657;"	d
vPortGenerateSimulatedInterrupt	.\freertos\portable\mingw\port.c	/^void vPortGenerateSimulatedInterrupt( uint32_t ulInterruptNumber )$/;"	f
vPortInitialiseBlocks	.\freertos\include\mpu_wrappers.h	124;"	d
vPortInitialiseBlocks	.\freertos\portable\memang\heap_4.c	/^void vPortInitialiseBlocks( void )$/;"	f
vPortSetInterruptHandler	.\freertos\portable\mingw\port.c	/^void vPortSetInterruptHandler( uint32_t ulInterruptNumber, uint32_t (*pvHandler)( void ) )$/;"	f
vQueueAddToRegistry	.\freertos\include\FreeRTOS.h	314;"	d
vQueueAddToRegistry	.\freertos\include\mpu_wrappers.h	127;"	d
vQueueAddToRegistry	.\freertos\queue.c	/^	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
vQueueDelete	.\freertos\include\mpu_wrappers.h	113;"	d
vQueueDelete	.\freertos\queue.c	/^void vQueueDelete( QueueHandle_t xQueue )$/;"	f
vQueueSetQueueNumber	.\freertos\queue.c	/^	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )$/;"	f
vQueueUnregisterQueue	.\freertos\include\FreeRTOS.h	315;"	d
vQueueUnregisterQueue	.\freertos\include\mpu_wrappers.h	128;"	d
vQueueUnregisterQueue	.\freertos\queue.c	/^	void vQueueUnregisterQueue( QueueHandle_t xQueue )$/;"	f
vQueueWaitForMessageRestricted	.\freertos\queue.c	/^	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )$/;"	f
vSemaphoreCreateBinary	.\freertos\include\semphr.h	127;"	d
vSemaphoreDelete	.\freertos\include\semphr.h	821;"	d
vTaskAllocateMPURegions	.\freertos\include\mpu_wrappers.h	79;"	d
vTaskAllocateMPURegions	.\freertos\tasks.c	/^	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )$/;"	f
vTaskDelay	.\freertos\include\mpu_wrappers.h	82;"	d
vTaskDelay	.\freertos\tasks.c	/^	void vTaskDelay( const TickType_t xTicksToDelay )$/;"	f
vTaskDelayUntil	.\freertos\include\mpu_wrappers.h	81;"	d
vTaskDelayUntil	.\freertos\tasks.c	/^	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )$/;"	f
vTaskDelete	.\freertos\include\mpu_wrappers.h	80;"	d
vTaskDelete	.\freertos\tasks.c	/^	void vTaskDelete( TaskHandle_t xTaskToDelete )$/;"	f
vTaskEndScheduler	.\freertos\tasks.c	/^void vTaskEndScheduler( void )$/;"	f
vTaskEnterCritical	.\freertos\tasks.c	/^	void vTaskEnterCritical( void )$/;"	f
vTaskExitCritical	.\freertos\tasks.c	/^	void vTaskExitCritical( void )$/;"	f
vTaskGetRunTimeStats	.\freertos\include\mpu_wrappers.h	93;"	d
vTaskGetRunTimeStats	.\freertos\tasks.c	/^	void vTaskGetRunTimeStats( char *pcWriteBuffer )$/;"	f
vTaskList	.\freertos\include\mpu_wrappers.h	92;"	d
vTaskList	.\freertos\tasks.c	/^	void vTaskList( char * pcWriteBuffer )$/;"	f
vTaskMissedYield	.\freertos\tasks.c	/^void vTaskMissedYield( void )$/;"	f
vTaskPlaceOnEventList	.\freertos\tasks.c	/^void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )$/;"	f
vTaskPlaceOnEventListRestricted	.\freertos\tasks.c	/^	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )$/;"	f
vTaskPlaceOnUnorderedEventList	.\freertos\tasks.c	/^void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )$/;"	f
vTaskPriorityDisinherit	.\freertos\tasks.c	/^	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )$/;"	f
vTaskPriorityInherit	.\freertos\tasks.c	/^	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )$/;"	f
vTaskPrioritySet	.\freertos\include\mpu_wrappers.h	84;"	d
vTaskPrioritySet	.\freertos\tasks.c	/^	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )$/;"	f
vTaskResume	.\freertos\include\mpu_wrappers.h	87;"	d
vTaskResume	.\freertos\tasks.c	/^	void vTaskResume( TaskHandle_t xTaskToResume )$/;"	f
vTaskSetApplicationTaskTag	.\freertos\include\mpu_wrappers.h	94;"	d
vTaskSetApplicationTaskTag	.\freertos\tasks.c	/^	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )$/;"	f
vTaskSetTaskNumber	.\freertos\tasks.c	/^	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )$/;"	f
vTaskSetTimeOutState	.\freertos\tasks.c	/^void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )$/;"	f
vTaskStartScheduler	.\freertos\tasks.c	/^void vTaskStartScheduler( void )$/;"	f
vTaskStepTick	.\freertos\tasks.c	/^	void vTaskStepTick( const TickType_t xTicksToJump )$/;"	f
vTaskSuspend	.\freertos\include\mpu_wrappers.h	86;"	d
vTaskSuspend	.\freertos\tasks.c	/^	void vTaskSuspend( TaskHandle_t xTaskToSuspend )$/;"	f
vTaskSuspendAll	.\freertos\include\mpu_wrappers.h	88;"	d
vTaskSuspendAll	.\freertos\tasks.c	/^void vTaskSuspendAll( void )$/;"	f
vTaskSwitchContext	.\freertos\tasks.c	/^void vTaskSwitchContext( void )$/;"	f
write_atomic_ringbuf	.\ringbuf.c	/^write_atomic_ringbuf(atomic_ringbuf_t *c, unsigned char *dataIn, unsigned int length)$/;"	f
write_ringbuf	.\ringbuf.c	/^int write_ringbuf(ringbuf_t *c, unsigned char *dataIn, unsigned int length)$/;"	f
xActiveTimerList1	.\freertos\timers.c	/^PRIVILEGED_DATA static List_t xActiveTimerList1;$/;"	v	file:
xActiveTimerList2	.\freertos\timers.c	/^PRIVILEGED_DATA static List_t xActiveTimerList2;$/;"	v	file:
xBlockAllocatedBit	.\freertos\portable\memang\heap_4.c	/^static size_t xBlockAllocatedBit = 0;$/;"	v	file:
xBlockSize	.\freertos\portable\memang\heap_4.c	/^	size_t xBlockSize;						\/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:
xCallbackParameters	.\freertos\timers.c	/^			CallbackParameters_t xCallbackParameters;$/;"	m	union:tmrTimerQueueMessage::__anon5	file:
xCoRoutineCreate	.\freertos\croutine.c	/^BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )$/;"	f
xCoRoutineHandle	.\freertos\include\FreeRTOS.h	739;"	d
xCoRoutineRemoveFromEventList	.\freertos\croutine.c	/^BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )$/;"	f
xCoRoutineTickCount	.\freertos\croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xConsumerTaskInitParams	.\consumer_task.h	/^typedef struct xConsumerTaskInitParams {$/;"	s
xConsumerTaskInitParams	.\consumer_task.h	/^} xConsumerTaskInitParams;$/;"	t	typeref:struct:xConsumerTaskInitParams
xConsumerTaskParams	.\consumer_task.h	/^typedef struct xConsumerTaskParams {$/;"	s
xConsumerTaskParams	.\consumer_task.h	/^} xConsumerTaskParams;$/;"	t	typeref:struct:xConsumerTaskParams
xDelayedCoRoutineList1	.\freertos\croutine.c	/^static List_t xDelayedCoRoutineList1;									\/*< Delayed co-routines. *\/$/;"	v	file:
xDelayedCoRoutineList2	.\freertos\croutine.c	/^static List_t xDelayedCoRoutineList2;									\/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xDelayedTaskList1	.\freertos\tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList1;						\/*< Delayed tasks. *\/$/;"	v	file:
xDelayedTaskList2	.\freertos\tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList2;						\/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xEventGroupClearBits	.\freertos\event_groups.c	/^EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )$/;"	f
xEventGroupClearBitsFromISR	.\freertos\event_groups.c	/^EventBits_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )$/;"	f
xEventGroupCreate	.\freertos\event_groups.c	/^EventGroupHandle_t xEventGroupCreate( void )$/;"	f
xEventGroupDefinition	.\freertos\event_groups.c	/^typedef struct xEventGroupDefinition$/;"	s	file:
xEventGroupGetBits	.\freertos\include\event_groups.h	634;"	d
xEventGroupGetBitsFromISR	.\freertos\include\event_groups.h	651;"	d
xEventGroupSetBits	.\freertos\event_groups.c	/^EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )$/;"	f
xEventGroupSetBitsFromISR	.\freertos\event_groups.c	/^	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xEventGroupSetBitsFromISR	.\freertos\include\event_groups.h	488;"	d
xEventGroupSync	.\freertos\event_groups.c	/^EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )$/;"	f
xEventGroupWaitBits	.\freertos\event_groups.c	/^EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )$/;"	f
xEventListItem	.\freertos\include\croutine.h	/^	ListItem_t			xEventListItem;		\/*< List item used to place the CRCB in event lists. *\/$/;"	m	struct:corCoRoutineControlBlock
xEventListItem	.\freertos\tasks.c	/^	ListItem_t			xEventListItem;		\/*< Used to reference a task from an event list. *\/$/;"	m	struct:tskTaskControlBlock	file:
xFreeBytesRemaining	.\freertos\portable\memang\heap_4.c	/^static size_t xFreeBytesRemaining = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE_ALIGNMENT_MASK );$/;"	v	file:
xGenericListItem	.\freertos\include\croutine.h	/^	ListItem_t			xGenericListItem;	\/*< List item used to place the CRCB in ready and blocked queues. *\/$/;"	m	struct:corCoRoutineControlBlock
xGenericListItem	.\freertos\tasks.c	/^	ListItem_t			xGenericListItem;	\/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). *\/$/;"	m	struct:tskTaskControlBlock	file:
xHandle	.\freertos\include\task.h	/^	TaskHandle_t xHandle;			\/* The handle of the task to which the rest of the information in the structure relates. *\/$/;"	m	struct:xTASK_STATUS
xHandle	.\freertos\queue.c	/^		QueueHandle_t xHandle;$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:
xIdleTaskHandle	.\freertos\tasks.c	/^	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			\/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. *\/$/;"	v	file:
xItemValue	.\freertos\include\list.h	/^	configLIST_VOLATILE TickType_t xItemValue;			\/*< The value being listed.  In most cases this is used to sort the list in descending order. *\/$/;"	m	struct:xLIST_ITEM
xItemValue	.\freertos\include\list.h	/^	configLIST_VOLATILE TickType_t xItemValue;$/;"	m	struct:xMINI_LIST_ITEM
xLIST	.\freertos\include\list.h	/^typedef struct xLIST$/;"	s
xLIST_ITEM	.\freertos\include\list.h	/^struct xLIST_ITEM$/;"	s
xLastTickCount	.\freertos\croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xList	.\freertos\include\FreeRTOS.h	748;"	d
xListEnd	.\freertos\include\list.h	/^	MiniListItem_t xListEnd;						\/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. *\/$/;"	m	struct:xLIST
xListItem	.\freertos\include\FreeRTOS.h	747;"	d
xMEMORY_REGION	.\freertos\include\task.h	/^typedef struct xMEMORY_REGION$/;"	s
xMINI_LIST_ITEM	.\freertos\include\list.h	/^struct xMINI_LIST_ITEM$/;"	s
xMPUSettings	.\freertos\tasks.c	/^		xMPU_SETTINGS	xMPUSettings;		\/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:
xMemoryRegion	.\freertos\include\FreeRTOS.h	735;"	d
xMessageID	.\freertos\timers.c	/^	BaseType_t			xMessageID;			\/*<< The command being sent to the timer service task. *\/$/;"	m	struct:tmrTimerQueueMessage	file:
xMessageValue	.\freertos\timers.c	/^	TickType_t			xMessageValue;		\/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. *\/$/;"	m	struct:tmrTimerParameters	file:
xMinimumEverFreeBytesRemaining	.\freertos\portable\memang\heap_4.c	/^static size_t xMinimumEverFreeBytesRemaining = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE_ALIGNMENT_MASK );$/;"	v	file:
xNewLib_reent	.\freertos\tasks.c	/^		struct 	_reent xNewLib_reent;$/;"	m	struct:tskTaskControlBlock	typeref:struct:tskTaskControlBlock::_reent	file:
xNextTaskUnblockTime	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;$/;"	v	file:
xNumOfOverflows	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;$/;"	v	file:
xOverflowCount	.\freertos\include\task.h	/^	BaseType_t xOverflowCount;$/;"	m	struct:xTIME_OUT
xPassedTicks	.\freertos\croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xPendingReadyCoRoutineList	.\freertos\croutine.c	/^static List_t xPendingReadyCoRoutineList;								\/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. *\/$/;"	v	file:
xPendingReadyList	.\freertos\tasks.c	/^PRIVILEGED_DATA static List_t xPendingReadyList;						\/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. *\/$/;"	v	file:
xPortGetFreeHeapSize	.\freertos\include\mpu_wrappers.h	123;"	d
xPortGetFreeHeapSize	.\freertos\portable\memang\heap_4.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f
xPortGetMinimumEverFreeHeapSize	.\freertos\portable\memang\heap_4.c	/^size_t xPortGetMinimumEverFreeHeapSize( void )$/;"	f
xPortRunning	.\freertos\portable\mingw\port.c	/^static BaseType_t xPortRunning = pdFALSE;$/;"	v	file:
xPortStartScheduler	.\freertos\portable\mingw\port.c	/^BaseType_t xPortStartScheduler( void )$/;"	f
xProducerTaskInitParams	.\producer_task.h	/^typedef struct xProducerTaskInitParams {$/;"	s
xProducerTaskInitParams	.\producer_task.h	/^} xProducerTaskInitParams;$/;"	t	typeref:struct:xProducerTaskInitParams
xProducerTaskParams	.\producer_task.h	/^typedef struct xProducerTaskParams {$/;"	s
xProducerTaskParams	.\producer_task.h	/^} xProducerTaskParams;$/;"	t	typeref:struct:xProducerTaskParams
xQUEUE	.\freertos\queue.c	/^} xQUEUE;$/;"	t	typeref:struct:QueueDefinition	file:
xQueueAddToSet	.\freertos\include\mpu_wrappers.h	117;"	d
xQueueAddToSet	.\freertos\queue.c	/^	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )$/;"	f
xQueueAltGenericReceive	.\freertos\include\mpu_wrappers.h	110;"	d
xQueueAltGenericReceive	.\freertos\queue.c	/^	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking )$/;"	f
xQueueAltGenericSend	.\freertos\include\mpu_wrappers.h	109;"	d
xQueueAltGenericSend	.\freertos\queue.c	/^	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )$/;"	f
xQueueAltPeek	.\freertos\include\queue.h	1454;"	d
xQueueAltReceive	.\freertos\include\queue.h	1453;"	d
xQueueAltSendToBack	.\freertos\include\queue.h	1452;"	d
xQueueAltSendToFront	.\freertos\include\queue.h	1451;"	d
xQueueCRReceive	.\freertos\queue.c	/^	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )$/;"	f
xQueueCRReceiveFromISR	.\freertos\queue.c	/^	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )$/;"	f
xQueueCRSend	.\freertos\queue.c	/^	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )$/;"	f
xQueueCRSendFromISR	.\freertos\queue.c	/^	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )$/;"	f
xQueueCreate	.\freertos\include\queue.h	169;"	d
xQueueCreateCountingSemaphore	.\freertos\include\mpu_wrappers.h	107;"	d
xQueueCreateCountingSemaphore	.\freertos\queue.c	/^	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )$/;"	f
xQueueCreateMutex	.\freertos\include\mpu_wrappers.h	104;"	d
xQueueCreateMutex	.\freertos\queue.c	/^	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )$/;"	f
xQueueCreateSet	.\freertos\include\mpu_wrappers.h	115;"	d
xQueueCreateSet	.\freertos\queue.c	/^	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )$/;"	f
xQueueGenericCreate	.\freertos\include\mpu_wrappers.h	103;"	d
xQueueGenericCreate	.\freertos\queue.c	/^QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )$/;"	f
xQueueGenericReceive	.\freertos\include\mpu_wrappers.h	111;"	d
xQueueGenericReceive	.\freertos\queue.c	/^BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )$/;"	f
xQueueGenericReset	.\freertos\include\mpu_wrappers.h	114;"	d
xQueueGenericReset	.\freertos\queue.c	/^BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )$/;"	f
xQueueGenericSend	.\freertos\include\mpu_wrappers.h	108;"	d
xQueueGenericSend	.\freertos\queue.c	/^BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )$/;"	f
xQueueGenericSendFromISR	.\freertos\queue.c	/^BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )$/;"	f
xQueueGetMutexHolder	.\freertos\queue.c	/^	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )$/;"	f
xQueueGiveMutexRecursive	.\freertos\include\mpu_wrappers.h	105;"	d
xQueueGiveMutexRecursive	.\freertos\queue.c	/^	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )$/;"	f
xQueueHandle	.\freertos\include\FreeRTOS.h	730;"	d
xQueueIsQueueEmptyFromISR	.\freertos\queue.c	/^BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )$/;"	f
xQueueIsQueueFullFromISR	.\freertos\queue.c	/^BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )$/;"	f
xQueueOverwrite	.\freertos\include\queue.h	500;"	d
xQueueOverwriteFromISR	.\freertos\include\queue.h	1183;"	d
xQueuePeek	.\freertos\include\queue.h	684;"	d
xQueuePeekFromISR	.\freertos\include\mpu_wrappers.h	119;"	d
xQueuePeekFromISR	.\freertos\queue.c	/^BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )$/;"	f
xQueueReceive	.\freertos\include\queue.h	810;"	d
xQueueReceiveFromISR	.\freertos\queue.c	/^BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )$/;"	f
xQueueRegistry	.\freertos\queue.c	/^	QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];$/;"	v
xQueueRegistryItem	.\freertos\queue.c	/^	} xQueueRegistryItem;$/;"	t	typeref:struct:QUEUE_REGISTRY_ITEM	file:
xQueueRemoveFromSet	.\freertos\include\mpu_wrappers.h	118;"	d
xQueueRemoveFromSet	.\freertos\queue.c	/^	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )$/;"	f
xQueueReset	.\freertos\include\queue.h	1492;"	d
xQueueSelectFromSet	.\freertos\include\mpu_wrappers.h	116;"	d
xQueueSelectFromSet	.\freertos\queue.c	/^	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )$/;"	f
xQueueSelectFromSetFromISR	.\freertos\queue.c	/^	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )$/;"	f
xQueueSend	.\freertos\include\queue.h	417;"	d
xQueueSendFromISR	.\freertos\include\queue.h	1257;"	d
xQueueSendToBack	.\freertos\include\queue.h	333;"	d
xQueueSendToBackFromISR	.\freertos\include\queue.h	1096;"	d
xQueueSendToFront	.\freertos\include\queue.h	251;"	d
xQueueSendToFrontFromISR	.\freertos\include\queue.h	1025;"	d
xQueueSetHandle	.\freertos\include\FreeRTOS.h	732;"	d
xQueueSetMemberHandle	.\freertos\include\FreeRTOS.h	733;"	d
xQueueTakeMutexRecursive	.\freertos\include\mpu_wrappers.h	106;"	d
xQueueTakeMutexRecursive	.\freertos\queue.c	/^	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )$/;"	f
xRegions	.\freertos\include\task.h	/^	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];$/;"	m	struct:xTASK_PARAMETERS
xRxLock	.\freertos\queue.c	/^	volatile BaseType_t xRxLock;	\/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:
xSchedulerRunning	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;$/;"	v	file:
xSemaphoreAltGive	.\freertos\include\semphr.h	517;"	d
xSemaphoreAltTake	.\freertos\include\semphr.h	356;"	d
xSemaphoreCreateBinary	.\freertos\include\semphr.h	181;"	d
xSemaphoreCreateCounting	.\freertos\include\semphr.h	807;"	d
xSemaphoreCreateMutex	.\freertos\include\semphr.h	689;"	d
xSemaphoreCreateRecursiveMutex	.\freertos\include\semphr.h	744;"	d
xSemaphoreGetMutexHolder	.\freertos\include\semphr.h	836;"	d
xSemaphoreGive	.\freertos\include\semphr.h	419;"	d
xSemaphoreGiveFromISR	.\freertos\include\semphr.h	608;"	d
xSemaphoreGiveRecursive	.\freertos\include\semphr.h	503;"	d
xSemaphoreHandle	.\freertos\include\FreeRTOS.h	731;"	d
xSemaphoreTake	.\freertos\include\semphr.h	248;"	d
xSemaphoreTakeFromISR	.\freertos\include\semphr.h	642;"	d
xSemaphoreTakeRecursive	.\freertos\include\semphr.h	341;"	d
xStart	.\freertos\portable\memang\heap_4.c	/^static BlockLink_t xStart, *pxEnd = NULL;$/;"	v	file:
xSuspendedTaskList	.\freertos\tasks.c	/^	PRIVILEGED_DATA static List_t xSuspendedTaskList;					\/*< Tasks that are currently suspended. *\/$/;"	v	file:
xTASK_PARAMETERS	.\freertos\include\task.h	/^typedef struct xTASK_PARAMETERS$/;"	s
xTASK_STATUS	.\freertos\include\task.h	/^typedef struct xTASK_STATUS$/;"	s
xTIMER	.\freertos\timers.c	/^} xTIMER;$/;"	t	typeref:struct:tmrTimerControl	file:
xTIME_OUT	.\freertos\include\task.h	/^typedef struct xTIME_OUT$/;"	s
xTaskCallApplicationTaskHook	.\freertos\include\mpu_wrappers.h	96;"	d
xTaskCallApplicationTaskHook	.\freertos\tasks.c	/^	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )$/;"	f
xTaskCheckForTimeOut	.\freertos\tasks.c	/^BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )$/;"	f
xTaskCreate	.\freertos\include\task.h	330;"	d
xTaskCreateRestricted	.\freertos\include\task.h	399;"	d
xTaskGenericCreate	.\freertos\include\mpu_wrappers.h	78;"	d
xTaskGenericCreate	.\freertos\tasks.c	/^BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
xTaskGetApplicationTaskTag	.\freertos\include\mpu_wrappers.h	95;"	d
xTaskGetApplicationTaskTag	.\freertos\tasks.c	/^	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )$/;"	f
xTaskGetCurrentTaskHandle	.\freertos\include\mpu_wrappers.h	98;"	d
xTaskGetCurrentTaskHandle	.\freertos\tasks.c	/^	TaskHandle_t xTaskGetCurrentTaskHandle( void )$/;"	f
xTaskGetIdleTaskHandle	.\freertos\include\mpu_wrappers.h	100;"	d
xTaskGetIdleTaskHandle	.\freertos\tasks.c	/^	TaskHandle_t xTaskGetIdleTaskHandle( void )$/;"	f
xTaskGetSchedulerState	.\freertos\include\mpu_wrappers.h	99;"	d
xTaskGetSchedulerState	.\freertos\tasks.c	/^	BaseType_t xTaskGetSchedulerState( void )$/;"	f
xTaskGetTickCount	.\freertos\include\mpu_wrappers.h	90;"	d
xTaskGetTickCount	.\freertos\tasks.c	/^TickType_t xTaskGetTickCount( void )$/;"	f
xTaskGetTickCountFromISR	.\freertos\tasks.c	/^TickType_t xTaskGetTickCountFromISR( void )$/;"	f
xTaskHandle	.\freertos\include\FreeRTOS.h	729;"	d
xTaskIncrementTick	.\freertos\tasks.c	/^BaseType_t xTaskIncrementTick( void )$/;"	f
xTaskNumber	.\freertos\include\task.h	/^	UBaseType_t xTaskNumber;		\/* A number unique to the task. *\/$/;"	m	struct:xTASK_STATUS
xTaskParameters	.\freertos\include\FreeRTOS.h	736;"	d
xTaskRemoveFromEventList	.\freertos\tasks.c	/^BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )$/;"	f
xTaskRemoveFromUnorderedEventList	.\freertos\tasks.c	/^BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )$/;"	f
xTaskResumeAll	.\freertos\include\mpu_wrappers.h	89;"	d
xTaskResumeAll	.\freertos\tasks.c	/^BaseType_t xTaskResumeAll( void )$/;"	f
xTaskResumeFromISR	.\freertos\tasks.c	/^	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )$/;"	f
xTaskStatusType	.\freertos\include\FreeRTOS.h	737;"	d
xTasksWaitingForBits	.\freertos\event_groups.c	/^	List_t xTasksWaitingForBits;		\/*< List of tasks waiting for a bit to be set. *\/$/;"	m	struct:xEventGroupDefinition	file:
xTasksWaitingTermination	.\freertos\tasks.c	/^	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				\/*< Tasks that have been deleted - but their memory not yet freed. *\/$/;"	v	file:
xTasksWaitingToReceive	.\freertos\queue.c	/^	List_t xTasksWaitingToReceive;	\/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:
xTasksWaitingToSend	.\freertos\queue.c	/^	List_t xTasksWaitingToSend;		\/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:
xThreadState	.\freertos\portable\mingw\port.c	/^} xThreadState;$/;"	t	typeref:struct:__anon3	file:
xTickCount	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;$/;"	v	file:
xTimeOnEntering	.\freertos\include\task.h	/^	TickType_t  xTimeOnEntering;$/;"	m	struct:xTIME_OUT
xTimeOutType	.\freertos\include\FreeRTOS.h	734;"	d
xTimerChangePeriod	.\freertos\include\timers.h	500;"	d
xTimerChangePeriodFromISR	.\freertos\include\timers.h	884;"	d
xTimerCreate	.\freertos\timers.c	/^TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
xTimerCreateTimerTask	.\freertos\timers.c	/^BaseType_t xTimerCreateTimerTask( void )$/;"	f
xTimerDelete	.\freertos\include\timers.h	538;"	d
xTimerGenericCommand	.\freertos\timers.c	/^BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )$/;"	f
xTimerGetTimerDaemonTaskHandle	.\freertos\timers.c	/^	TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )$/;"	f
xTimerHandle	.\freertos\include\FreeRTOS.h	738;"	d
xTimerIsTimerActive	.\freertos\timers.c	/^BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )$/;"	f
xTimerListItem	.\freertos\timers.c	/^	ListItem_t				xTimerListItem;		\/*<< Standard linked list item as used by all kernel features for event management. *\/$/;"	m	struct:tmrTimerControl	file:
xTimerParameters	.\freertos\timers.c	/^		TimerParameter_t xTimerParameters;$/;"	m	union:tmrTimerQueueMessage::__anon5	file:
xTimerPendFunctionCall	.\freertos\timers.c	/^	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )$/;"	f
xTimerPendFunctionCallFromISR	.\freertos\timers.c	/^	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xTimerPeriodInTicks	.\freertos\timers.c	/^	TickType_t				xTimerPeriodInTicks;\/*<< How quickly and often the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:
xTimerQueue	.\freertos\timers.c	/^PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;$/;"	v	file:
xTimerReset	.\freertos\include\timers.h	662;"	d
xTimerResetFromISR	.\freertos\include\timers.h	970;"	d
xTimerStart	.\freertos\include\timers.h	378;"	d
xTimerStartFromISR	.\freertos\include\timers.h	748;"	d
xTimerStop	.\freertos\include\timers.h	420;"	d
xTimerStopFromISR	.\freertos\include\timers.h	811;"	d
xTimerTaskHandle	.\freertos\timers.c	/^	PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;$/;"	v	file:
xTotalHeapSize	.\freertos\portable\memang\heap_4.c	/^static const size_t xTotalHeapSize = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE_ALIGNMENT_MASK );$/;"	v	file:
xTxLock	.\freertos\queue.c	/^	volatile BaseType_t xTxLock;	\/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:
xYieldPending	.\freertos\tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;$/;"	v	file:
